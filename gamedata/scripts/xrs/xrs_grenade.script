-- -*- mode: lua; coding: windows-1251-dos -*-
--------------------------------------------------------------------------------
--' Схема метания гранат и убегания от них
--' мод OGSE, версия 2.5, 18/08/2011
--' автор: xStream
--' переработка, доработки алгоритма: KamikaZze
--------------------------------------------------------------------------------

local forbidden_comms = {       -- запретные коммунити
  [ "arena_enemy"   ] = true,
  [ "ecolog"        ] = true,
  [ "quest_stalker" ] = true,
  [ "trader"        ] = true,
  [ "zombied"       ] = true,
}

local gr_types = {
  "grenade_f1",
  "grenade_rgd5",
}


function attach( sm )
  sm:subscribe({ signal = "on_npc_death", fun = this.on_death     })
  sm:subscribe({ signal = "on_npc_spawn", fun = this.on_npc_spawn })
  sm:subscribe({ signal = "on_take",      fun = this.fake_pickup  })
  sm:subscribe({ signal = "on_spawn",     fun = this.init_grenade_radius })
end


function on_npc_spawn( obj, binder )
  if not obj:alive() then return end
  if
    forbidden_comms[ obj:character_community() ]
    or obj:character_community() == "quest_stalker"
    or obj:name() == "mil_stalker0012"
    or obj:name() == "yantar_ecolog_general"
    or string.find( obj:section(), "arena" )
    or string.find( obj:section(), "aem" )
    or rx_utils.IsTrader( obj )
  then
    return
  end
  local s = {
    [ "signal" ] = "on_npc_update." .. obj:id(),
    [ "fun"    ] = this.npc_update,
  }
  binder[ "xrs_grenade.subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ "xrs_grenade.subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
  end
  death_callback( obj )
end


local grenade_owners = {}
local grenade_times  = {}
local grenades       = {}
local grenadiers     = {}
local test_grenades  = {}

local grenade_max_dist = 50
local grenade_bone     = "bip01_head"

local snd_grenade_replics = {
  [ "stalker" ] = {
    "stalker\\ready_1",
    "stalker\\ready_2",
    "stalker\\ready_3",
    "stalker\\ready_4",
    "stalker\\ready_5",
    "stalker\\ready_6",
    "stalker\\ready_7",
    "stalker\\ready_8",
  },
  [ "military" ] = {
    "voyaki\\ready_1",
    "voyaki\\ready_2",
    "voyaki\\ready_3",
  },
  [ "bandit" ] = {
    "bandos\\ready_1",
    "bandos\\ready_2",
    "bandos\\ready_3",
    "bandos\\ready_4",
    "bandos\\ready_5",
    "bandos\\ready_6",
    "bandos\\ready_7",
    "bandos\\ready_8",
    "bandos\\ready_9",
    "bandos\\ready_10",
  },
  [ "monolith" ] = {
    "mono\\ready_1",
    "mono\\ready_2",
    "mono\\ready_3",
  },
  [ "killer" ] = {
    "merc\\ready_1",
    "merc\\ready_2",
  },
  [ "vermaht" ] = {
    "vermaht\\ready_1",
  },
  [ "dolg" ] = {
    "dolgos\\abuse_3",
    "dolgos\\backup_3",
    "dolgos\\panic_monster_2",
    "dolgos\\panic_monster_4",
    "dolgos\\search_8",
    "dolgos\\threat_distant_2",
    "dolgos\\threat_distant_5",
  },
  [ "freedom" ] = {
    "freedom\\freedom1",
    "freedom\\freedom2",
    "freedom\\freedom3",
  },
}


class "evaluator_love_napalm_smell" ( property_evaluator )
function evaluator_love_napalm_smell:__init( name, storage ) super( nil, name )
  self.a = storage
  self.a.grenades = {}
  for k, v in ipairs( gr_types ) do
    local t = {}
    t.radius, t.explode_time = get_grenade_radius( v )
    self.a.grenades[ v ] = t
  end
  self:set_next_check_time()
end


function evaluator_love_napalm_smell:set_next_check_time()
  self.a.next_check_time = time_global() + math.random( 5000, 10000 )
end


function evaluator_love_napalm_smell:too_many_test_grenades()
  local cnt = 0
  for id, time in pairs( test_grenades ) do
    cnt = cnt + 1
  end
  return cnt >= 20
end


function evaluator_love_napalm_smell:evaluate()
  if not self.object:alive() then return false end

  if self.a.throwing then
    ogse_debug.add_active_eval( self.object, script_name(), "love_napalm_smell_2" )
    return true
  end

  if self.testing then
    if not self:check_testing() then return false end
    if not self.test_begun then
      self:check_test_begun()
    elseif self.test_end_time < time_global() then
      self:check_test_running()
      if self.a.throwing then
        ogse_debug.add_active_eval(
          self.object, script_name(), "love_napalm_smell"
        )
        return true
      end
    end
    return false
  end

  if self.a.next_check_time > time_global() then return false end
  self:set_next_check_time()

  local npc = self.object
  local st  = xrs_battle_ai.get_schema_storage( npc )
  if not ( st and st.ready_to_grenade ) then return false end
  local be  = xrs_battle_ai.get_target( npc )
  if not be then return false end

  local curr_gr
  for _, v in ipairs( gr_types ) do
    curr_gr = npc:object( v )
    if curr_gr and self:check_grenade( curr_gr:section(), be ) then break end
    curr_gr = nil
  end
  if not curr_gr then return false end
  if self:too_many_test_grenades() then return false end

  -- можно швыряться - вероятность никого не задеть (кроме врагов)
  -- достаточно велика
  self.a.target_point = be:position()
--[=[
    :add(
      vector_rotate_y( be:position():sub( npc:position() ), 90 )
        :normalize():mul( 2 )
    )
--]=]
  self.a.grenade = curr_gr:id()
  local timeout  = time_global()
    + self.a.grenades[ curr_gr:section() ].explode_time
  self.testing = {}
  for _, force in ipairs({ 8000, 19000, math.random( 30000, 60000 ) }) do
    local sobj = alife():create(
      curr_gr:section() .. "_test",
      npc:bone_position( grenade_bone ),
      npc:level_vertex_id(), npc:game_vertex_id()
    )
    level.client_spawn_manager():add( sobj.id, -1, self.on_spawn_testing, self )
    self.testing[ sobj.id ] = {
      [ "throw" ] = force,
    }
    test_grenades[ sobj.id ] = timeout + 5000
  end
  run_grenade_timer()
  self.test_end_time      = timeout
  self.test_grenades_sect = curr_gr:section()

  return false
end


function evaluator_love_napalm_smell:check_testing()
  local testing = true
  for id, t in pairs( self.testing ) do
    if not alife():object( id ) then
      testing = false
      break
    end
  end
  if testing then return true end
  for id, t in pairs( self.testing ) do
    local sobj = alife():object( id )
    if sobj then
      alife():release( sobj )
    end
    test_grenades[ id ] = nil
    if not t.spawned then
      level.client_spawn_manager():remove( id, -1 )
    end
  end
  self:set_next_check_time()
  self.test_begun = false
  self.testing    = false
  return false
end


function evaluator_love_napalm_smell:on_spawn_testing( _, obj )
  if not self.testing then return end
  mark_grenade_non_pickable( obj )
  local t = self.testing[ obj:id() ]
  t.spawned = true
end


function evaluator_love_napalm_smell:check_test_begun()
  self.test_begun = true
  for id, t in pairs( self.testing ) do
    if t.spawned then
      if not t.kicked then
        throw( id, t.throw, self.a.target_point )
        t.kicked = true
        self.test_begun = false
      end
    else
      self.test_begun = false
    end
  end
  if self.test_begun then
    self.test_end_time = time_global()
      + self.a.grenades[ self.test_grenades_sect ].explode_time
  end
end


function evaluator_love_napalm_smell:check_test_running()
  local npc    = self.object
  local pos    = npc:position()
  local radius = self.a.grenades[ self.test_grenades_sect ].radius
  local ready_dist, ready_id
  for id, t in pairs( self.testing ) do
    local obj = level.object_by_id( id )
    if obj:position():distance_to( pos ) > radius then
      local dist = obj:position():distance_to( self.a.target_point )
      if dist < radius then
        if ( not ready_id ) or dist < ready_dist then
          ready_dist = dist
          ready_id   = id
        end
      end
    end
  end
  local st = xrs_battle_ai.get_schema_storage( npc )
  if
    ready_id and st and st.ready_to_grenade
    and level.object_by_id( self.a.grenade )
  then
    local obj = level.object_by_id( ready_id )
    if obj then
      local fr_inj, en_inj = check_victims( npc, obj:position(), radius )
      if not fr_inj then
        self.a.throwing      = true
        self.a.throwing_type = self.testing[ ready_id ].throw
      end
    end
  end
  for id, t in pairs( self.testing ) do
    local sobj = alife():object( id )
    if sobj then
      alife():release( sobj )
    end
    test_grenades[ id ] = nil
  end
  self:set_next_check_time()
  self.test_begun = false
  self.testing    = false
end


function evaluator_love_napalm_smell:check_grenade( section, be )
  local npc = self.object

  local bp         = be:position()
  local np         = npc:position()
  local throw_dist = np:distance_to( bp )

  -- нельзя использовать дымовую гранату ночью, а световую днем
  -- if section == "grenade_light" and utils.is_day() then return false end

  -- далеко кидать никак, мы ж не атлеты...
  if throw_dist > grenade_max_dist then return false end
  -- если накроет взрывом - не будем кидать
  if throw_dist < self.a.grenades[ section ].radius then return false end

  -- можно использовать эту гранату....
  return true
end


class "action_kill_it_with_fire" ( action_base )
function action_kill_it_with_fire:__init( name, storage ) super( nil, name )
  self.a = storage
end


function action_kill_it_with_fire:initialize()
  action_base.initialize( self )
  self.at_pos           = false
  self.begin_throw      = false
  self.throw_end        = false
  self.time_back_to_pos = time_global() + 5000
  self.can_explode      = false
  self.finalized        = false
  local npc = self.object
  xr_sound.set_sound( npc, nil )
  stop_play_sound( npc )
  self.state_mgr_state = state_mgr.get_state( npc )
  state_mgr.set_state( npc, "idle" )
end


function action_kill_it_with_fire:execute()
  action_base.execute ( self )
  if self.finalized then return end
  if not level.object_by_id( self.a.grenade ) then
    self.a.throwing = false
    return
  end

  local npc = self.object
  npc:set_item( object.idle, nil )
--[=[
  npc:set_sight( look.point, self.a.target_point )
  npc:set_desired_direction( self.a.target_point:sub( npc:position() ) )
--]=]
  local dir = vector():sub( self.a.target_point, npc:position() )
  npc:set_sight( look.direction, dir )
  npc:set_desired_direction( dir )

  if not self.at_pos then
    npc:set_movement_type( move.stand )
    npc:set_mental_state( anim.danger )
    npc:set_body_state( move.standing )
    npc:set_dest_level_vertex_id( npc:level_vertex_id() )
    local snd_sect = snd_grenade_replics[ npc:character_community() ]
      or snd_grenade_replics.stalker
    local snd_rnd  = math.random( table.getn( snd_sect ) + 1 )
    if snd_rnd <= table.getn( snd_sect ) then
      local snd = "grenadier\\" .. snd_sect[ snd_rnd ]
      snd = xr_sound.get_safe_sound_object( snd )
      if snd then
        snd:play_no_feedback( npc, sound_object.s3d, 0, npc:position(), 1.0 )
      end
    end
    grenadiers[ npc:id() ] = self.a.grenade
    self.at_pos  = true
    self.state   = 0
    self.timeout = time_global() + 1000
    return
  end

  if self.state == 0 then
    if
      self.timeout > time_global()
      and (
        npc:active_item() or npc:animation_count() > 0
        or npc:body_state() ~= move.standing or npc:is_body_turning()
      )
    then
      return
    end
    if self.a.throwing_type <= 8000 then
      npc:add_animation( "udar_0" )
    else
      npc:add_animation( "norm_all_6_attack_2" )
    end
    self.state   = self.state + 1
    self.timeout = time_global() + 1000
    return

  elseif self.state == 1 then
    local obj = level.object_by_id( self.a.grenade )
    npc:drop_item_and_teleport( obj, npc:bone_position( grenade_bone ) )
    self.state   = self.state + 1
    self.timeout = time_global() + 1000

  elseif self.state == 2 then
    local obj = level.object_by_id( self.a.grenade )
    if self.timeout > time_global() and obj:parent() then
      return
    end
    throw( self.a.grenade, self.a.throwing_type, self.a.target_point )
    local r, dt = get_grenade_radius( obj:section() )
    grenades[ self.a.grenade ] = time_global() + dt
    run_grenade_timer()
    grenade_owners[ self.a.grenade ] = npc:id()
    grenade_times[  self.a.grenade ] = time_global()
    grenadiers[ npc:id() ] = nil
    self.a.grenade         = nil
    self.state   = self.state + 1
    self.timeout = time_global() + 1000

  elseif self.state == 3 then
    if self.timeout > time_global() and npc:animation_count() > 0 then
      return
    end
    self.a.next_check_time = time_global() + math.random( 10000, 30000 )
    self.a.target_point    = nil
    self.a.throwing        = false
    self.finalized         = true
    state_mgr.set_state( npc, self.state_mgr_state )
  end
end


function action_kill_it_with_fire:finalize()
  action_base.finalize( self )
end


-- Функции включения/выключения схемы
function set_scheme( npc, ini, scheme, section )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
  if st then st.enabled = true end
end


function disable_scheme( npc, scheme )
  local st = db.storage[ npc:id() ][ scheme ]
  if st then st.enabled = false end
end


local grenade_data = {}
function init_grenade_radius()
  for _, sect in ipairs( gr_types ) do
    local br = get_float( sect, "blast_r" )
    ASSERT( br, "[%s]: blast_r not found in %s", script_name(), sect )
    local fr = get_float( sect, "frags_r" )
    ASSERT( fr, "[%s]: frags_r not found in %s", script_name(), sect )
    local dt = get_float( sect, "destroy_time" )
    ASSERT( dt, "[%s]: destroy_time not found in %s", script_name(), sect )
    grenade_data[ sect ] = {
      [ "destroy_time" ] = dt,
      [ "radius"       ] = math.max( 10, br, fr ),
    }
  end
end


function get_grenade_radius( sect )
  local t = grenade_data[ sect ]
  ASSERT( t, "[%s]: grenade_data.%s not found", script_name(), sect )
  return t.radius, t.destroy_time
end


local visible_grenades = {}
local exploding = {}

function update()
  for k, v in pairs( grenades ) do
    local sobj = alife():object( k )
    if sobj and sobj.parent_id == 65535 then
      if v < time_global() then
        local explode = true
        local obj     = level.object_by_id( k )
        if obj then
          local npc_id = grenade_owners[ k ]
          if npc_id then
            local npc = level.object_by_id( npc_id )
            if npc then
              local fr_inj, en_inj = check_victims(
                npc, obj:position(), get_grenade_radius( obj:section() )
              )
              explode = not fr_inj
            end
          end
          if explode then
            exploding[ obj:id() ] = npc_id
            mark_grenade_non_pickable( obj )
            obj:explode_initiator( npc_id )
          end
        end
        if not explode then
          alife():release( sobj )
        end
        grenade_owners[ k ]   = nil
        grenade_times[ k ]    = nil
        grenades[ k ]         = nil
        visible_grenades[ k ] = nil
      else
        local obj = level.object_by_id( k )
        if obj and not visible_grenades[ k ] then
          local vel = vector():set( 0, 0, 0 )
          obj:get_physics_shell():get_linear_vel( vel )
          if vel:magnitude() < 10 then
            visible_grenades[ k ] = true
          end
        end
      end
    else
      grenade_owners[ k ]   = nil
      grenade_times[ k ]    = nil
      grenades[ k ]         = nil
      visible_grenades[ k ] = nil
    end
  end

  for k, v in pairs( test_grenades ) do
    local sobj = alife():object( k )
    if sobj then
      if v < time_global() then
        alife():release( sobj )
        test_grenades[ k ] = nil
      end
    else
      test_grenades[ k ] = nil
    end
  end

  for id, _ in pairs( exploding ) do
    if not ( level.object_by_id( id ) or alife():object( id ) ) then
      exploding[ id ] = nil
    end
  end
end


function death_callback( npc )
  local grenade = grenadiers[ npc:id() ]
  if not grenade then return end
  grenadiers[ npc:id() ] = nil
  local g_obj = level.object_by_id( grenade )
  if not g_obj then return end
  grenade = alife():create(
    g_obj:section(),
    npc:bone_position( grenade_bone ),
    npc:level_vertex_id(), npc:game_vertex_id()
  )
  local dummy, timeout = get_grenade_radius( g_obj:section() )
  grenades[ grenade.id ] = time_global() + timeout
  run_grenade_timer()
end


function npc_update( npc )
  ogse_signals.get_mgr():reschedule( math.random( 50000, 60000 ) )
  local t = {}
  for _, sect in ipairs( gr_types ) do
    if npc:object( sect ) then return end
    table.insert( t, sect )
  end
  dsh.shuffle( t )
  for _, sect in ipairs( t ) do
    local prb = npc:character_rank() / 1500
    if prb > 0.9  then prb = 0.9  end
    if prb < 0.01 then prb = 0.01 end
    if math.random() < prb then
      alife():create(
        sect,
        npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
      )
      return
    end
  end
end


function throw( id, force, target )
  local obj  = level.object_by_id( id )
  local bone = obj:get_physics_shell():get_element_by_bone_name( "wpn_body" )
  local dir  = utils.vector_copy_by_val( target ):sub( obj:position() )
  dir:mul( 1300 )
  dir:add( vector():set( 0, force, 0 ) )
  bone:apply_force(
    dir.x + math.random( -3, 3 ), dir.y, dir.z + math.random( -3, 3 )
  )
end


function fake_pickup( obj )
  for k, v in ipairs( gr_types ) do
    if
      obj:section() == v .. "_test"
      or obj:section() == v .. "_fake"
    then
      local sobj = alife():object( obj:id() )
      if sobj then
        alife():release( sobj )
      end
      return
    end
  end
end


local grenade_t
function run_grenade_timer()
  if not grenade_t then
    grenade_t = check_grenade_timer():start()
  end
end

class "check_grenade_timer" ( ogse_qt.quick_timer )
function check_grenade_timer:__init() super()
end

function check_grenade_timer:condition()
  for _, t in ipairs({ exploding, grenades, test_grenades }) do
    for k, v in pairs( t ) do
      return false
    end
  end
  return true
end

function check_grenade_timer:action()
  grenade_t = nil
end

function check_grenade_timer:update()
  update()
end


function get_grenade_owner_id( id )
  return exploding[ id ]
end


function check_victims( npc, pos, radius )
  local fr_inj, en_inj = false, false
  for id, is_npc in pairs( db.creature ) do
    if is_npc then
      local obj = level.object_by_id( id )
      if obj and obj:alive() then
        local dist = pos:distance_to( obj:position() )
        if dist <= radius then
          if xrs_battle_ai.check_is_enemy( npc, obj ) then
            en_inj = true
          else
            fr_inj = true
            break
          end
        end
      end
    end
  end
  return fr_inj, en_inj
end


function get_gr_types()
  return gr_types
end


function iterate_active_grenades( f )
  for id, _ in pairs( visible_grenades ) do
    local obj = level.object_by_id( id )
    if obj then
      local radius = get_grenade_radius( obj:section() )
      f( obj, grenade_owners[ id ], radius )
    end
  end
end


local base = 18670 -- 87460
prop_fire            = base + 0
evid_crazy_grenadier = prop_fire

local base_act = base -- 87480
act_kill_it = base_act + 0
act_run     = base_act + 1


function add_to_binder( object, char_ini, scheme, section, st )
  local manager = object:motivation_action_manager()
  local property_wounded         = xr_evaluators_id.sidor_wounded_base
  local state_mgr_to_idle_combat = xr_actions_id.state_mgr + 1
  local state_mgr_to_idle_alife  = xr_actions_id.state_mgr + 2
  manager:remove_evaluator( prop_fire )
  if forbidden_comms[ object:character_community() ] or not object:alive() then
    manager:add_evaluator( prop_fire, property_evaluator_const( false ) )
    return
  end
  manager:add_evaluator(
    prop_fire, evaluator_love_napalm_smell( "evaluator_love_napalm_smell", st )
  )

  local action = action_kill_it_with_fire( "action_kill_it_with_fire", st )
  action:add_precondition( world_property( stalker_ids.property_alive, true ) )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  action:add_precondition( world_property( property_wounded, false ) )
  action:add_precondition( world_property( prop_fire, true ) )
  action:add_effect( world_property( prop_fire, false ) )
  manager:add_action( act_kill_it, action )

  action = manager:action( stalker_ids.action_combat_planner )
  action:add_precondition( world_property( prop_fire, false ) )

  action = manager:action( stalker_ids.action_danger_planner )
  action:add_precondition( world_property( prop_fire, false ) )

  action = manager:action( state_mgr_to_idle_alife )
  action:add_precondition( world_property( prop_fire, false ) )
  -- action:add_precondition( world_property( prop_grenade, false ) )

  action = manager:action( state_mgr_to_idle_combat )
  action:add_precondition( world_property( prop_fire, false ) )
end
