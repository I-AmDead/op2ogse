-- -*- mode: lua; coding: windows-1251-dos -*-
-----------------------------------------------------------------------
--- xrs_battle_ai.script
--- Модуль боевки
--- Автор: KamikaZze
--- Идея, советы: xStream
--- version 4.38 (10/03/2015)
-----------------------------------------------------------------------
--- Настройки:
-----------------------------------------------------------------------

-- Параметры адаптивной дисперсии при стрельбе по актору. Дисперсия
-- будет меняться с коэффициентом от max до min в течении time.
local firing_actor_disp_max  = 2
local firing_actor_disp_min  = 1
local firing_actor_disp_time = 3000

local total_debug               = false
local close_combat_distance     = 15 -- дистанция ближнего боя
-- дистанция когда бой уже не считается ближним
local distant_combat_distance   = 35
local cooldown_time             = 20000 -- время запрета лута после боя
-- интервал реприоретизации, мсек - нельзя делать слишком низким -
-- будет судорожно метаться между целями
local reprioritize_timeout      = 1500
-- время, сколько помнить о появлении врага, миллиссекунд
local memory_timeout            = 80000
-- сколько помнить о последнем основном враге (нужно для
-- предотвращения выхода из боя слишком рано), для неписей умножается
-- на 2
local remember_enemy            = 10000
-- С какого апдейта схема начинает работать. Нельзя чтобы схема
-- стартовала включенной сразу же, иначе будут глюки на переключении
-- схем и выборе оружия
local engage_after_update       = 3
local visibility_treshold_value = 0.45 -- трешхолд видимости

-- вероятность сказать фразу
local sound_prob_event = 0.6
local sound_prob_hero  = 0.1
local sound_prob_idle  = 0.1

hit_timeout = {}


-- локации где можно атаковать БТР и вертолеты
local armor_allowed_locations = {}

-- состояния не готовности к огню, нужно заставить встать перед
-- началом стрельбы
local not_ready_states = {
  [ "busy"     ] = true,
  [ "sit"      ] = true,
  [ "sit_knee" ] = true,
  [ "sit_ass"  ] = true,
  [ "sleep"    ] = true,
  [ "wounded_heavy"] = true,
  [ "guard"    ] = true,
  [ "patrol"   ] = true,
}

local low_range_npc_aggr = 30
local far_range_mon_aggr = 50
local low_range_mon_aggr =  5

local combat_mult_npc     = 0.5 -- множитель веса ближней цели неписей
local combat_mult_monster = 0.3 -- множитель веса ближней цели неписей

local max_invisible_range_npc = 12
local max_invisible_range_mon =  5

local forbidden_comms = {       -- запретные коммунити
  [ "zombied" ] = true,
}

local forbidden_schemes = {     -- запретные схемы
  [ "wounded" ] = true
}

local forbidden_profiles = {    -- запретные профили и имена
  [ "aes_Monolit_sniper_gauss" ] = true,
  [ "Monolit_sniper_gauss"     ] = true,
  [ "pri_monolith_roof3"       ] = true,
  [ "pri_stalker_n_2"          ] = true,
  [ "pri_stalker_n_2_0000"     ] = true,
  [ "pri_monolith_roof3_0000"  ] = true,
  [ "pri_monolith_roof3_0001"  ] = true,
  [ "pri_stalker_n_2_0001"     ] = true,
  [ "pri_stadium_sniper1"      ] = true,
  [ "pri_stadium_sniper2"      ] = true,
  [ "pri_stadium_sniper3"      ] = true,
  [ "pri_monolith_roof1"       ] = true,
  [ "pri_monolith_roof2"       ] = true,
  [ "val_sacrifice_victim"     ] = true,
  [ "val_prisoner_captive"     ] = true,
  [ "val_escort_captive"       ] = true,
  [ "bandit_trader"            ] = true,
  [ "bandit_trader_spawn"      ] = true,
  [ "dik_the_drifter"          ] = true,
  [ "major_wounded"            ] = true,
  [ "gen_monolit_sniper"       ] = true,
  [ "aes_Monolit_rpg"          ] = true,
  [ "hohol"                    ] = true,
  [ "esc_lekar"                ] = true,
  [ "first_neutral"            ] = true,
  [ "esc_buharik"              ] = true,
  [ "esc_guns_remontnik"       ] = true,
  -- пацаны в саркофаге должны быть под движковой боевкой
  [ "sar_monolith_exo"         ] = true,
  [ "sar_monolith_exo_crystal" ] = true,
  [ "sar_monolith_specnaz"     ] = true,
  [ "sar_monolith_commander"   ] = true,
}

local forbidden_by_lname = {
  -- [ "l12u_control_monolith" ] = true,
  -- [ "l12u_sarcofag"         ] = true,
}

local community_forbidden_locations = {
  -- [ "monolith" ] = {
  --   [ "l12_stancia_2" ] = true,
  -- },
}

local headshot_prob = {
  [ "novice"      ] = 0,
  [ "experienced" ] = 0.05,
  [ "veteran"     ] = 0.1,
  [ "master"      ] = 0.2,
}


function attach( sm )
  sm:subscribe({ signal = "on_npc_death", fun = this.death_place  })
  sm:subscribe({ signal = "on_npc_hit",   fun = this.hit_callback })
  sm:subscribe({ signal = "on_npc_net_destroy", fun = go_offline  })
  sm:subscribe({ signal = "on_spawn",     fun = this.on_spawn     })
end


--- время на прицеливание
--- для эффективной стрельбы из дробовика необходимо,
--- чтобы выдерживался интервал между выстрелами,
--- иначе подброс ствола испортит всю картину
--- для новичков логично этот параметр сделать низким и увеличивать с опытом
local time_to_aim = {
  [ "novice"      ] = {
    shotgun = 350, sniper = 1500, other = 350, rpg = 3500,
  },
  [ "experienced" ] = {
    shotgun = 300, sniper = 1000, other = 300, rpg = 3000,
  },
  [ "veteran"     ] = {
    shotgun = 250, sniper =  800, other = 250, rpg = 2500,
  },
  [ "master"      ] = {
    shotgun = 200, sniper =  500, other = 200, rpg = 2000,
  },
}

--- отклонение прицела
local deviation_table = {
  [ "novice"      ] = 0.65,
  [ "experienced" ] = 0.6,
  [ "veteran"     ] = 0.5,
  [ "master"      ] = 0.45,
}

--- коэффициент отклонения по коммунити
local community_deviation_coeff = {
  [ "lastday"       ] =  1,
  [ "monolith"      ] =  1,
  [ "trader"        ] =  1,
  [ "killer"        ] =  1.2,
  [ "military"      ] =  1.2,
  [ "sniper"        ] =  1.2,
  [ "vermaht"       ] =  1.2,
  [ "stalker"       ] =  1.4,
  [ "zombied"       ] = 15,
}

--- группировки с улучшенной координацией (имеют радиосвязь, соотв. об
--- одной цели сразу знают все члены группировки)
local radio_comms = {
  [ "military" ] = true,
  [ "killer"   ] = true,
  [ "monolith" ] = true,
  [ "dolg"     ] = true,
}

local needed_dangers = {
  [ danger_object.attack_sound    ] = true,
  [ danger_object.bullet_ricochet ] = true,
  [ danger_object.attacked        ] = true,
  [ danger_object.grenade         ] = true,
  [ danger_object.enemy_sound     ] = true
}

local targeting_dangers = {
  [ danger_object.attacked ] = true
}


-----------------------------------------------------------------------
--- Данные:
-----------------------------------------------------------------------
cooldown                        = {}
in_combat                       = {}
primary_target                  = {} -- таблица целей

local last_time_send            = {}
local last_sent_vertex          = {}
local last_hideout              = {}
local sounds_timeout            = {}
local disabled_objects          = {} -- таблица забытых объектов
local targets_list              = {} -- список целей
local last_reprioritize         = {} -- время приоретизации
local last_target               = {} -- последняя цель
local last_enemy_id             = {}         -- ид последнего врага
local inited                    = {}         -- инициализированы ли
local bad_hide                  = {} -- ненадежное укрытие
local locked_vertexes           = {} -- занятые вертексы
local death_places              = {} -- места смерти союзников, избегать их
local time_hide                 = {} -- время ожидания
local hit_memory                = {} -- хитоая память
local deadman_vtx               = {} -- точка откуда будем ждать успокоения
local grenka_already_blow       = {}
local escape_point              = {}
local last_choosed_path         = {}
local sound_events              = {}
local sound_are_playing         = {}
local already_know_about        = {}


local ignore_enemies = {}
function check_is_enemy( npc, enemy, fast )
  if not npc or not enemy then return false end
  local is_engine_enemy = npc:is_relation_enemy( enemy )
  if is_engine_enemy then
    if
      ignore_enemies[ npc:name() ]
      and ignore_enemies[ npc:name() ][ enemy:name() ]
    then
      return false
    end
    return fast and true or npc:binded_object():enemy_callback( npc, enemy )
  end
  return false
end


function on_spawn()
  local dsh_sect = "dsh.xrs_battle_ai.ignore_enemies"
  if sys_ini:section_exist( dsh_sect ) then
    for _, k in ipairs( get_section_keys( dsh_sect ) ) do
      for _, name in ipairs( parse_names( get_string( dsh_sect, k ) ) ) do
        ignore_enemies[ k ][ name ] = true
      end
    end
  end
end


function is_combat_ignore( npc, enemy )
  return not xr_combat_ignore.is_enemy( npc, enemy )
end


function get_obj_rank_name( obj )
  local enemy = get_target( obj )
  if
    enemy and enemy:id() == db.actor:id()
    and db.actor:character_rank() > obj:character_rank()
  then
    obj = db.actor
  end
  return ranks.get_obj_rank_name( obj )
end


function get_best_weapon( npc )
  local sl = npc:active_slot()
  if sl ~= NO_ACTIVE_SLOT and npc:item_in_slot( sl ) then
    return npc:item_in_slot( sl )
  else
    local wm = rx_wmgr.get_wm( npc )
    return ( wm and wm:get_weapon() ) or npc:best_weapon()
  end
end


-- продолжаем вооруженное общение до умиротворения объекта
class "evaluator_check_altcombat" ( property_evaluator )
function evaluator_check_altcombat:__init( name, storage ) super( nil, name )
  self.st = storage
  self.count_update  = 0
  self.known_corpses = {}
end


function evaluator_check_altcombat:evaluate()
  if self.count_update <= engage_after_update then
    self.count_update = self.count_update + 1
    return false
  end

  if
    ( not self.object:alive() )
    or xr_wounded.is_wounded( self.object )
    or (
      db.storage[ self.object:id() ].active_scheme
      and forbidden_schemes[ db.storage[ self.object:id() ].active_scheme ]
    )
  then
    return false
  end

  if not inited[ self.object:id() ] then
    -- произведем инициализацию таблиц данных селектора
    targets_list[ self.object:id() ] = {}        -- список целей
    last_target[ self.object:id()  ] = {}        -- последняя цель
    setup_sound_table( self.object )
    inited[ self.object:id()       ] = true
    local ini = battle.is_battle_spawned( self.object )
    if ini then
      local actor_is_enemy = get_bool(
        "battle", "xrs_battle_ai.actor_is_enemy", false, ini
      )
      if actor_is_enemy then
        register_as_target( self.object, db.actor, true )
      end
    end
  end

  self:check_corpse_danger()
  reprioritize_targets( self.object )
  if self:check_for_grenades( self.object ) then
    ogse_debug.add_active_eval( self.object, script_name(), "altcombat_gr" )
    return true
  end

  local bw         = get_best_weapon( self.object )
  local npc_rank   = get_obj_rank_name( self.object )
  local targ       = have_fresh_deadman( self.object )
  local best_enemy = get_target( self.object )
  if best_enemy then
    if
      (
        best_enemy:alive()
        or ( is_armor( best_enemy ) and armor_alive( best_enemy ) )
      )
      and (
        not ( best_enemy:is_stalker() and xr_wounded.is_wounded( best_enemy ) )
      )
      and ( not is_exclusion( self.object ) )
      and bw
    then
      ogse_debug.add_active_eval( self.object, script_name(), "altcombat" )
      return true
    else
      if targ and not is_exclusion( self.object ) then
        ogse_debug.add_active_eval( self.object, script_name(), "altcombat_2" )
        return true
      end
      return false
    end
  else
    if targ and not is_exclusion( self.object ) then
      local obj = level.object_by_id( targ )
      if not (
        obj:is_stalker() and obj:alive() and xr_wounded.is_wounded( obj )
      ) then
        ogse_debug.add_active_eval( self.object, script_name(), "altcombat_3" )
        return true
      end
    end
    return false
  end
end


function evaluator_check_altcombat:check_corpse_danger()
  local npc         = self.object
  local best_danger = npc:best_danger()
  if not best_danger then return false end
  if best_danger:type() ~= danger_object.entity_corpse then return false end

  local bd_object = best_danger:object()
  if self.known_corpses[ bd_object:id() ] then return false end
  self.known_corpses[ bd_object:id() ] = true
  if bd_object:is_actor() or check_is_enemy( npc, bd_object ) then
    return false
  end

  local killer_id = dsh_deadmans.is_fresh_deadman( bd_object:id() )
  if not (
    killer_id and killer_id ~= bd_object:id() and killer_id ~= npc:id()
  ) then
    return false
  end

  local enemy = level.object_by_id( killer_id )
  if
    enemy and enemy:alive()
    and ( enemy:is_actor() or enemy:is_custom_monster() )
    and ( not ( enemy:is_stalker() and xr_wounded.is_wounded( enemy ) ) )
    and check_is_enemy( npc, enemy )
  then
    register_as_target( npc, enemy, true )
    return true
  end

  return false
end


function evaluator_check_altcombat:check_for_grenades()
  local npc = self.object

  if self.st.active_grenade then
    local check = self.st.active_grenade
    local obj   = level.object_by_id( check.grenade )
    if check.timeout < time_global() or not ( obj and obj:is_grenade() ) then
      grenka_already_blow[ check.name ] = time_global()
    end
  end

  local grenade = self:get_nearest_grenade()
  if
    grenade and (
      ( not self.st.active_grenade )
      or self.st.active_grenade.grenade ~= grenade.grenade
    )
  then
    self.st.active_grenade = grenade
  end

  grenade = self.st.active_grenade
  if not grenade then return false end
  if not grenade.inertion then
    grenade.inertion = time_global() + math.random( 500, 1500 )
    return false
  end
  if grenade.inertion > time_global() then return false end

  if not grenade.run then
    local parent = level.object_by_id( grenade.parent )
    if parent and check_is_enemy( npc, parent ) then
      enable_object( npc, parent )
      process_enemy( npc, parent )
    end
    grenade.run = true
  end

  return true
end


function evaluator_check_altcombat:get_nearest_grenade()
  local npc = self.object

  local best_danger = npc:best_danger()
  if best_danger then
    local bd_type = best_danger:type()
    if bd_type == danger_object.grenade then
      local bd_object = best_danger:dependent_object()
      if
        bd_object
        and level.object_by_id( bd_object:id() )
        and bd_object:is_grenade()
        and (
          ( not grenka_already_blow[ bd_object:name() ] )
          or time_global() - grenka_already_blow[ bd_object:name() ] > 5000
        )
      then
        grenka_already_blow[ bd_object:name() ] = nil
        local dist   = npc:position():distance_to( bd_object:position() )
        local radius = xrs_grenade.get_grenade_radius( bd_object:section() )
        if dist < radius * 0.9 then
          return {
            [ "grenade" ] = bd_object:id(),
            [ "name"    ] = bd_object:name(),
            [ "parent"  ] = best_danger:object():id(),
            [ "timeout" ] = time_global() + 5000,
          }
        end
      end
    end
  end
end


class "action_altcombat" ( action_base )
function action_altcombat:__init( npc, action_name, storage ) super( nil, action_name )
  self.st = storage
end


function action_altcombat:initialize()
  action_base.initialize( self )
  local npc = self.object
  xr_sound.set_sound( npc, nil )
  npc:movement_enabled( true )
  stop_play_sound( npc )
  npc:set_item( object.idle, nil )
  self:check_objects()
  sr_light.check_light( npc )
  set_sound_event( npc, "start" )
  state_mgr.set_state( npc, "threat" )

  if
    db.storage[ npc:id() ]
    and db.storage[ npc:id() ].active_scheme == "camper"
  then
    self.st.is_camper = npc:level_vertex_id()
  else
    self.st.is_camper = nil
  end

  self.can_fire = false
  self.check_ready_state = true
  in_combat[ npc:id() ] = true
end


function playing_hit_animation( npc )
  local t = hit_timeout[ npc:id() ]
  if t and t > time_global() and npc:animation_count() > 0 then
    return true
  elseif t then
    hit_timeout[ npc:id() ] = nil
  end
  return false
end


function action_altcombat:not_ready_state()
  local npc = self.object
  if self.check_ready_state then
    local t = db.storage[ npc:id() ]
    if t and t.state_mgr then
      local anim = t.state_mgr.animstate:state()
      if not_ready_states[ anim ] then return true end
    end
    self.check_ready_state = nil
  end
  if playing_hit_animation( npc ) then return true end
  return false
end


function action_altcombat:execute()
  local pt = profile_timer()
  pt:start()
  self.firing_actor = false
  self:_execute()
  if not self.firing_actor then
    self.start_firing_actor = nil
  end
  pt:stop()
  if pt:time() > 20000 then
    log2(
      "[%s]: %s: action_altcombat:execute() too slow: %s",
      script_name(), self.object:name(), pt:time()
    )
  end
end


function action_altcombat:_execute()
  action_base.execute( self )
  self.st.ready_to_grenade = false
  local npc = self.object

  if self:not_ready_state() then return end

  if xr_wounded.is_wounded( npc ) or not self.object:alive() then
    reset_everything( npc )
    return
  end

  if self:evade_grenades() then return end
  local has_grenade = self.st.active_grenade

  self.object:movement_enabled( true )
  self.object:set_desired_direction()
  self.object:set_desired_position()
  self.object:set_detail_path_type( move.curve )
  self.object:set_path_type( game_object.level_path )

  local enemy = get_target( npc ) -- текущий враг
  local deadman
  if not ( enemy or has_grenade ) then
    deadman = have_fresh_deadman( npc )
  end
  if not ( enemy or deadman ) then
    deadman_vtx[ npc:id()       ] = nil
    last_time_send[ npc:id()    ] = nil
    last_enemy_id[ npc:id()     ] = nil
    primary_target[ npc:id()    ] = nil
    last_reprioritize[ npc:id() ] = nil
    return
  end

  -- получим текущее оружие
  local bw = get_best_weapon( npc )

  -- если ещё свежий труп
  if deadman then
    stop_play_sound( npc )
    local deadman_target = level.object_by_id( deadman )
    if not deadman_target then
      reset_everything( npc )
      return
    end
    local last_deadman_id = deadman_vtx[ npc:id() ]
    if ( not last_deadman_id ) or last_deadman_id ~= deadman then
      deadman_vtx[    npc:id() ] = deadman
      last_time_send[ npc:id() ] = nil
      local lvid = find_cover( npc, deadman_target, random_choice( 1, 3, 4 ) )
      if lvid then
        utils.send_to_nearest_accessible_vertex( npc, lvid )
      end
    end
    self:set_combat_sight( deadman_target, bw )
    self:set_transfer_state( deadman_target )
    last_enemy_id[ npc:id() ] = nil
    return
  else
    deadman_vtx[ npc:id() ] = nil
  end

  -- строим список врагов/друзей, проверяем линию огня - в своих и
  -- нейтралов чтоб не стрелять
  self:check_objects( bw, enemy )

  -- инициализация боя
  if
    enemy
    and (
      ( not last_enemy_id[ npc:id() ] )
      or enemy:id() ~= last_enemy_id[ npc:id() ]
    )
  then
    last_enemy_id[ npc:id() ] = enemy:id()
    enable_object( self.object, enemy )
    if bw then self.object:set_item( object.aim1, bw ) end
    notify_friends( self.object, enemy )
    self:set_combat_sight( enemy, bw )
  end

  local npc_pos  = npc:position()
  local be       = enemy
  local npc_rank = get_obj_rank_name( npc )
  local be_pos   = be:position()
  local distance = be_pos:distance_to( npc_pos )
  local assist_point, cover, last_algorythm

  process_combat_sound( npc )
  local cur_situation = 0

  self:set_combat_sight( be, bw )
  if has_grenade then
    time_hide[ npc:id() ] = nil
    cur_situation  = 1
    last_algorythm = "grenade"
    if self.can_fire then
      self:set_weapons_fire( be, bw, false, npc_rank )
    end

  elseif distance < 5 then
    time_hide[ npc:id() ] = nil
    cur_situation  = 2
    last_algorythm = "find_cover_6"
    if self.can_fire then
      self:set_combat_state( be, bw )
      self:set_weapons_fire( be, bw, false, npc_rank )
    else
      self:set_transfer_state( be )
    end
    choose_idle_scheme(npc, "defence")

  elseif
    ( npc:see_right_now( be ) and be:see( npc ) )
    or ( is_armor( be ) and get_armor_vis( be, npc ) )
  then
    -- если видим врага и он видит нас - стреляем, ищем укрытие
    time_hide[ npc:id() ] = nil
    cur_situation  = 3
    last_algorythm = "find_cover_2"

    if self.can_fire then
      self:set_combat_state( be, bw )
      self:set_weapons_fire( be, bw, false, npc_rank )
    else
      self:set_transfer_state( be )
    end
    choose_idle_scheme( npc, "attack" )

  elseif
    ( npc:see_right_now( be ) and not be:see( npc ) )
    or ( is_armor( be ) and not get_armor_vis( be, npc ) )
  then
    -- если видим врага и он НЕ видит нас - стреляем, маневрируя
    self.st.ready_to_grenade = true
    time_hide[ npc:id() ] = nil
    cur_situation = 4
    if self.st.is_camper then
      last_algorythm = "find_cover_5"
    else
      last_algorythm = random_choice(
        "find_cover_1", "find_cover_3", "find_cover_4"
      )
    end

    if self.can_fire then
      self:set_combat_state( be, bw )
      self:set_weapons_fire( be, bw, false, npc_rank )
    else
      self:set_transfer_state( be )
    end
    choose_idle_scheme( npc, "attack_notsee" )

  elseif ( not npc:see_right_now( be ) ) and be:see( npc ) then
    -- если НЕ видим врага и он видит нас - убегаем, ищем укрытие
    time_hide[ npc:id() ] = nil
    cur_situation  = 5
    last_algorythm = "find_cover_2"

    self:set_transfer_state( be )
    choose_idle_scheme(npc, "defence")

  else
    -- если НЕ видим врага и он НЕ видит нас - ищем врага
    self.st.ready_to_grenade = true
    if not time_hide[ npc:id() ] then
      time_hide[ npc:id() ] = time_global() + math.random( 7000, 15000 )
    end
    if self.st.is_camper then
      cur_situation  = 6
      last_algorythm = "find_cover_5"
    else
      if time_hide[ npc:id() ] < time_global() then
        if self:actor_at_height( be ) then
          cur_situation  = 7
          last_algorythm = random_choice( "find_cover_2", "find_cover_7" )
        else
          cur_situation  = 8
          last_algorythm = random_choice(
            "find_cover_1", "find_cover_3", "find_cover_4"
          )
        end
      else
        cur_situation  = 9
        last_algorythm = random_choice( "find_cover_2", "find_cover_7" )
      end
    end

    self:set_transfer_state( be, true )
    choose_idle_scheme( npc, "lost" )
  end

  local lcp     = last_choosed_path[ npc:id() ]
  local use_lcp = false
  if
    lcp and lcp.situation == cur_situation and lcp.be == be:id()
    and be:position():distance_to( lcp.pos ) < 5
  then
    use_lcp = true
  end
  if not use_lcp then
    if not lcp then
      lcp = {}
      last_choosed_path[ npc:id() ] = lcp
    end
    lcp.alg       = last_algorythm
    lcp.be        = be:id()
    lcp.pos       = be:position()
    lcp.situation = cur_situation
    last_time_send[ npc:id() ] = nil
  end

  local actions = {
    [ "find_cover_0"  ] = function() return find_cover( npc, be, 0 ) end,
    [ "find_cover_1"  ] = function() return find_cover( npc, be, 1 ) end,
    [ "find_cover_2"  ] = function() return find_cover( npc, be, 2 ) end,
    [ "find_cover_3"  ] = function() return find_cover( npc, be, 3 ) end,
    [ "find_cover_4"  ] = function() return find_cover( npc, be, 4 ) end,
    [ "find_cover_5"  ] = function() return
      find_cover( npc, be, 5, self.st.is_camper )
    end,
    [ "find_cover_6"  ] = function() return find_cover( npc, be, 6 ) end,
    [ "find_cover_7"  ] = function() return find_cover( npc, be, 7 ) end,
    [ "grenade"       ] = function() return 0 end,
  }
  ASSERT(
    last_algorythm and actions[ last_algorythm ],
    "[%s]: %s: wrong last_algorythm = %s",
     script_name(), npc:name(), tostring( last_algorythm )
  )
  assist_point = actions[ last_algorythm ]()

  if assist_point and assist_point ~= 0 then
    utils.send_to_nearest_accessible_vertex( npc, assist_point )
  end
end


function action_altcombat:actor_at_height( be )
  if not be:is_actor() then return false end
  local height = db.actor:position().y - self.object:position().y
  if height < 3 then return false end
  if
    ( not self.actor_at_height_inert )
    or self.actor_at_height_inert < time_global()
  then
    self.actor_at_height_inert     = time_global() + math.random( 60 ) * 1000
    self.actor_at_height_threshold = math.random( 2 )
  end
  return ( self.actor_at_height_threshold > 1 )
end


function action_altcombat:check_objects( bw, enemy )
  local npc = self.object
  self.objects = {}
  self.objects.monsters = {}
  self.objects[ game_object.friend  ] = {}
  self.objects[ game_object.neutral ] = {}
  self.objects[ game_object.enemy   ] = {}

  for o in npc:memory_visible_objects() do
    self:check_single_object( o:object() )
  end

  for o in npc:memory_sound_objects() do
    self:check_single_object( o:object() )
  end

  if enemy and bw and IsRPG( bw ) then
    for _, t in ipairs({ game_object.friend, game_object.neutral }) do
      for k, v in pairs( self.objects[ t ] ) do
        if self:check_npc_on_fire_line( v, bw, enemy ) then
          self.can_fire = false
          return
        end
      end
    end
  end

  if bw and bw:is_weapon() then
    self.can_fire = bw:get_weapon():ready_to_kill()
  else
    self.can_fire = false
  end
end


function action_altcombat:check_single_object( obj )
  if not obj then return end
  if not ( obj:is_actor() or obj:is_custom_monster() ) then return end
  local npc = self.object
  if obj:alive() and npc:id() ~= obj:id() then
    if
      ( obj:is_actor() or obj:is_stalker() )
      and primary_target[ npc:id() ] ~= obj:id()
    then
      self.objects[ npc:relation( obj ) ][ obj:id() ] = obj
    elseif obj:is_monster() then
      self.objects.monsters[ obj:id() ] = obj
    end
  end
end


function action_altcombat:check_npc_on_fire_line( obj, weapon, be )
  if not IsRPG( weapon ) then return false end
  local npc         = self.object
  local npc_pos     = npc:bone_position( "bip01_spine" )
  local be_pos      = be:bone_position(  "bip01_spine" )
  local friend_pos  = obj:bone_position( "bip01_spine" )
  return (
    be_pos:distance_to( friend_pos ) < 25
    or be_pos:distance_to( npc_pos ) < 25
    or friend_pos:distance_to( npc_pos ) < 25
  )
end


local grenka_already_shout = {}

function action_altcombat:evade_grenades()
  if not self.st.active_grenade then return false end
  local npc        = self.object
  local danger     = self.st.active_grenade
  local id         = danger.grenade
  local danger_obj = level.object_by_id( id )

  local blown = grenka_already_blow[ danger.name ]
  if blown or not danger_obj then
    self.st.active_grenade = nil
    npc:set_mental_state( anim.danger )
    if not blown then
      grenka_already_blow[ danger.name ] = time_global()
    end
    escape_point[ npc:id() ] = nil
    return false
  end

  local ep = escape_point[ npc:id() ]
  if ( not ep ) or ep.id ~= id then
    last_hideout[    npc:id() ] = nil
    last_time_send[  npc:id() ] = nil
    locked_vertexes[ npc:id() ] = nil
    local pos    = npc:position()
    local dist   = pos:distance_to( danger_obj:position() )
    local dvert = find_cover( npc, danger_obj, 2 )
    if not dvert then
      dvert = npc:level_vertex_id()
    end
    ep = {
      [ "id"   ] = id,
      [ "lvid" ] = dvert,
    }
    escape_point[ npc:id() ] = ep
    stop_play_sound( npc )
    if danger.parent ~= npc:id() and not grenka_already_shout[ id ] then
      grenka_already_shout[ id ] = true
      xr_sound.set_sound_play( npc, "beware_grenade" )
    end
  end
  utils.send_to_nearest_accessible_vertex( npc, ep.lvid )

  local enemy = get_target( npc )
  if npc:path_completed() and enemy then
    npc:set_sight( enemy, true, true )
    return false
  elseif npc:path_completed() then
    if not enemy then
      enemy = level.object_by_id( danger.parent ) or danger_obj
    end
    npc:set_sight( enemy, true, true )
    npc:set_movement_type( move.stand )
    npc:set_mental_state( anim.danger )
    npc:set_body_state( move.crouch )
  else
    npc:set_sight( look.path_dir, true, true )
    npc:set_movement_type( move.run )
    npc:set_mental_state( anim.danger )
    npc:set_body_state( move.standing )
  end

  return true
end


function action_altcombat:finalize()
  action_base.finalize( self )
  local npc = self.object
  xr_sound.set_sound( npc, nil )
  npc:movement_enabled( true )
  stop_play_sound( npc )
  sr_light.check_light( npc )
  cooldown[  npc:id() ] = time_global() + cooldown_time
  in_combat[ npc:id() ] = nil
  self.combat_sight        = nil
  self.start_firing_actor  = nil
  self.st.ready_to_grenade = nil
  npc:stalker_disp_base( 0 )
end


function check_friends_enemy( npc, enemy_id )
  local function check_enemy( npc, obj )
    if
      obj and obj.clsid  and IsStalker( obj ) and obj:alive()
      and npc:id() ~= obj:id() and obj:id() ~= db.actor:id()
    then
      if
        npc:relation( obj ) == game_object.friend
        or (
          radio_comms[ npc:character_community() ]
          and npc:character_community() == obj:character_community()
        )
        or (
          npc:relation( obj ) ~= game_object.enemy
          and npc:position():distance_to( obj ) < 25
        )
      then
        if
          primary_target[ obj:id() ]
          and primary_target[ obj:id() ] == enemy_id
        then
          return true
        end
      end
    end
    return false
  end
  for o in npc:memory_visible_objects() do
    if check_enemy( npc, o:object() ) then return true end
  end
  for o in npc:memory_sound_objects() do
    if check_enemy( npc, o:object() ) then return true end
  end
  return false
end


function notify_friends( npc, enemy )
  local function notify_friend( npc, obj )
    if
      obj and obj.clsid and IsStalker( obj ) and obj:alive()
      and npc:id() ~= obj:id()
      and obj:id() ~= db.actor:id()
      and not xr_wounded.is_wounded( obj )
    then
      if
        npc:relation( obj ) == game_object.friend
        or (
          radio_comms[ npc:character_community() ]
          and npc:character_community() == obj:character_community()
        )
        or (
          npc:relation( obj ) ~= game_object.enemy
          and npc:position():distance_to( obj ) < 25
        )
      then
        process_enemy( obj, enemy )
      end
    end
  end
  local notified = {}
  for o in npc:memory_visible_objects() do
    if not notified[ o:object():id() ] then
      notify_friend( npc, o:object() )
      notified[ o:object():id() ] = true
    end
  end
  for o in npc:memory_sound_objects() do
    if not notified[ o:object():id() ] then
      notify_friend( npc, o:object() )
      notified[ o:object():id() ] = true
    end
  end
end


function disable_object( npc, enemy ) -- забыть объект
  if npc and enemy then
    local id = enemy:id()
    if not disabled_objects[ npc:id() ] then
      disabled_objects[ npc:id() ] = {}
    end
    if not disabled_objects[ npc:id() ][ id ] then
      npc:enable_memory_object( enemy, false )
      disabled_objects[ npc:id() ][ id ] = id
    end
  end
end


function enable_object( npc, enemy ) -- вспомнить объект
  if npc and enemy then
    local id = enemy:id()
    if disabled_objects[ npc:id() ] and disabled_objects[ npc:id() ][ id ] then
      npc:enable_memory_object( enemy, true )
      disabled_objects[ npc:id() ][ id ] = nil
    end
  end
end


local crit_anims = {
  [ "pistol" ] = {
    {
      [ "belly"      ] = "norm_1_critical_hit_torso_0",
      [ "hand_left"  ] = "norm_1_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_1_critical_hit_hend_right_0",
      [ "head"       ] = "norm_1_critical_hit_head_0",
      [ "leg_left"   ] = "norm_1_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_1_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_1_critical_hit_torso_0",
    },
  },
  [ "rifle" ] = {
    {
      [ "belly"      ] = "norm_8_critical_hit_torso_2",
      [ "hand_left"  ] = "norm_8_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_8_critical_hit_hend_right_0",
      [ "head"       ] = "norm_8_critical_hit_head_0",
      [ "leg_left"   ] = "norm_8_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_8_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_8_critical_hit_torso_1",
    },
    {
      [ "head"       ] = "norm_8_critical_hit_head_1",
      [ "hand_left"  ] = "norm_8_critical_hit_hend_left_2",
      [ "hand_right" ] = "norm_8_critical_hit_hend_right_2",
      [ "leg_left"   ] = "norm_8_critical_hit_legs_left_1",
      [ "leg_right"  ] = "norm_8_critical_hit_legs_right_1",
      [ "torso"      ] = "norm_2_critical_hit_torso_0",
      [ "belly"      ] = "norm_2_critical_hit_torso_1",
    },
    {
      [ "belly"      ] = "norm_3_critical_hit_torso_0",
      [ "hand_left"  ] = "norm_3_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_3_critical_hit_hend_right_0",
      [ "head"       ] = "norm_3_critical_hit_head_0",
      [ "leg_left"   ] = "norm_3_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_3_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_2_critical_hit_torso_0",
    },
  },
}

function hit_fx( obj, amount, who, bone_index )
  if ( not bone_index ) or bone_index == 0 then return end
  if ( not obj ) or xr_wounded.is_wounded( obj ) or not obj:alive() then
    return
  end
  if playing_hit_animation( obj ) then return end

  local max_hit = 0.3
  local rel_hit = math.min( amount / max_hit, 1 )
  if math.random() > rel_hit then return end

  local key_3
  if bone_index < 5 then
    key_3 = "leg_left"
  elseif bone_index < 9 then
    key_3 = "leg_right"
  elseif bone_index == 9 then
    key_3 = "belly"
  elseif bone_index == 10 then
    key_3 = "torso"
  elseif bone_index < 18 then
    key_3 = "head"
  elseif bone_index < 31 then
    key_3 = "hand_left"
  elseif bone_index < 40 then
    key_3 = "hand_right"
  else
    return
  end

  local binder = obj:binded_object()
  if not binder.last_hit_data then return end
  local hd       = binder.last_hit_data
  local hit_type = hd.hit_type
  ASSERT( hit_type, "hit_type not found" )
  if not ( hit_type == hit.fire_wound or hit_type == hit.explosion ) then
    return
  end
  if not ( hd.weapon_id or hd.who_id ) then return end
  local wpn = level.object_by_id( hd.weapon_id or hd.who_id )
  if not wpn then return end

  local weap_class = get_u32( wpn:section(), "ef_weapon_type" )
  if not weap_class then return end

  local t
  if weap_class > 5 then
    t = crit_anims.rifle
  else
    t = crit_anims.pistol
  end
  local step = 1 / table.getn( t )
  local idx  = math.min( table.getn( t ), math.floor( rel_hit / step ) + 1 )

  local anim = t[ idx ][ key_3 ]
  obj:clear_animations()
  obj:set_movement_type( move.stand )
  obj:set_mental_state( anim.danger )
  obj:set_body_state( move.standing )
  obj:set_dest_level_vertex_id( obj:level_vertex_id() )
  obj:add_animation( anim, true, false )
  hit_timeout[ obj:id() ] = time_global() + 3000
end


local damage_from_actor = {}

function hit_callback( obj, amount, local_direction, who, bone_index )
  -- если объект был ранее забыт - очухиваем его, если нету в табличке
  -- записываем в табличку
  local npc = obj
  if who and npc and who:id() == npc:id() then return end

  if in_combat[ npc:id() ] and amount > 0.01 then
    hit_fx( npc, amount, who, bone_index )
    if in_hideout( npc ) then
      death_places[ npc:level_vertex_id() ] = {
        [ "killer" ] = who:id(),
        [ "ttl"    ] = time_global() + 30000,
      }
    end
  end

  if
    amount and amount > 0.01 and npc:alive()
    and not xr_wounded.is_wounded( npc )
  then
    if who:is_actor() or who:is_stalker() then
      if who:alive() then
        if
          targets_list[ npc:id() ] and not targets_list[ npc:id() ][ who:id() ]
        then
          if who:id() == db.actor:id() then
            enable_object( npc, who )
            if check_is_enemy( npc, who ) then
              register_as_target( npc, who )
            else
              if not damage_from_actor[ npc:id() ] then
                damage_from_actor[ npc:id() ] = amount
              else
                damage_from_actor[ npc:id() ] =
                  damage_from_actor[ npc:id() ] + amount
              end
              if damage_from_actor[ npc:id() ] > 0.2 then
                register_as_target( npc, who )
              end
            end
            -- npc:make_object_visible_somewhen( who )
          else
            enable_object( npc, who )
            process_enemy( npc, who )
            -- npc:make_object_visible_somewhen( who )
          end
        elseif
          targets_list[ npc:id() ] and targets_list[ npc:id() ][ who:id() ]
        then
          local enemy_record = targets_list[ npc:id() ][ who:id() ]
          enemy_record.last_time_seen = time_global()
          enemy_record.vertex         = who:level_vertex_id()
        end
        if
          not (
            (
              npc:relation( who ) ~= game_object.enemy
              or npc:character_community() == who:character_community()
            )
            and who:id() ~= db.actor:id()
          )
        then
          if not hit_memory[ npc:id() ] then
            hit_memory[ npc:id() ] = {}
          end
          local mem = hit_memory[ npc:id() ]
          mem[ who:id() ] = true
          if amount > 0.1 then
            primary_target[ npc:id() ] = who:id()
          end
        elseif
          npc:relation(who) ~= game_object.enemy
          or npc:character_community() == who:character_community()
        then
          set_sound_event( npc, "ff" )
        end
      end
    elseif who:is_monster() then
      if who:alive() then
        if
          targets_list[ npc:id() ] and not targets_list[ npc:id() ][ who:id() ]
        then
          enable_object( npc, who )
          process_enemy( npc, who )
          -- npc:make_object_visible_somewhen( who )
        elseif
          targets_list[ npc:id() ] and targets_list[ npc:id() ][ who:id() ]
        then
          local enemy_record = targets_list[ npc:id() ][ who:id() ]
          enemy_record.last_time_seen = time_global()
          enemy_record.vertex         = who:level_vertex_id()
        end
        if not hit_memory[ npc:id() ] then
          hit_memory[ npc:id() ] = {}
        end
        local mem = hit_memory[ npc:id() ]
        mem[ who:id() ] = true
        if amount > 0.1 then
          primary_target[ npc:id() ] = who:id()
        end
      end
    elseif is_armor( who ) and armor_alive( who ) then
      if
        targets_list[ npc:id() ] and not targets_list[ npc:id() ][ who:id() ]
      then
        enable_object( npc, who )
        process_enemy( npc, who )
        -- npc:make_object_visible_somewhen( who )
      elseif
        targets_list[ npc:id() ] and targets_list[ npc:id() ][ who:id() ]
      then
        local enemy_record = targets_list[ npc:id() ][ who:id() ]
        enemy_record.last_time_seen = time_global()
        enemy_record.vertex         = who:level_vertex_id()
      end
    end

    if in_hideout( npc ) and last_hideout[ npc:id() ] then
      locked_vertexes[ 0 ] = last_hideout[ npc:id() ].vtx
      bad_hide[ last_hideout[ npc:id() ].vtx ] = time_global() + 30000
      last_hideout[ npc:id()     ] = nil
      last_sent_vertex[ npc:id() ] = nil
    end
    last_time_send[ npc:id() ] = nil

    local deadman = have_fresh_deadman( npc )
    if deadman then
      last_target[ npc:id() ][ deadman ] = nil
      last_enemy_id[ npc:id()     ] = nil
      primary_target[ npc:id()    ] = nil
      last_reprioritize[ npc:id() ] = nil
    end
  end
end


function death_place( obj, who )
  local npc       = obj
  local vertex    = npc:level_vertex_id()
  for k, v in pairs( death_places ) do
    if v.ttl <= time_global() or v.killer == obj:id() then
      death_places[ k ] = nil
    end
  end
  death_places[ vertex ] = {
    killer = who:id(),
    ttl    = time_global() + 300000,
  }
  reset_everything( npc )
end


function go_offline( obj )
  reset_everything( obj )
end


function reset_everything( npc )
  cooldown[ npc:id() ] = nil
  deadman_vtx[ npc:id() ] = nil
  disabled_objects[ npc:id() ] = nil
  escape_point[ npc:id() ] = nil
  hit_memory[ npc:id() ] = nil
  inited[ npc:id() ] = nil
  last_choosed_path[ npc:id() ] = nil
  last_enemy_id[ npc:id() ] = nil
  last_hideout[ npc:id() ] = nil
  last_reprioritize[ npc:id() ] = nil
  last_sent_vertex[ npc:id() ] = nil
  last_time_send[ npc:id() ] = nil
  locked_vertexes[ npc:id() ] = nil
  primary_target[ npc:id() ] = nil
  sounds_timeout[ npc:id() ] = nil
  targets_list[ npc:id() ] = {}
  time_hide[ npc:id() ] = nil
end


function its_a_trap( npc, vertex )
  local community  = npc:character_community()
  local vertex_pos = level.vertex_position( vertex )
  for k, v in pairs( death_places ) do
    if v.ttl > time_global() then
      local k_pos = level.vertex_position( k )
      if k == vertex or k_pos:distance_to( vertex_pos ) < 5 then
        local enemy = level.object_by_id( v.killer )
        if
          enemy
          and ( enemy:is_actor() or enemy:is_stalker() )
          and enemy:alive()
          and not xr_wounded.is_wounded( enemy )
        then
          return check_is_enemy( npc, enemy )
        elseif enemy and is_armor( enemy ) and armor_alive( enemy ) then
          return true
        else
          death_places[ k ] = nil
        end
      end
    else
      death_places[ k ] = nil
    end
  end
  return false
end


function process_enemy( npc, may_be_enemy )
  local valid, enemy = validate_enemy_object( may_be_enemy )
  if valid == false or not enemy then return end
  if npc:id() ~= enemy:id() then
    if not already_know_about[ npc:id() ] then
      already_know_about[ npc:id() ] = {}
    end
    if
      npc:relation( enemy ) == game_object.friend
      or (
        IsStalker( enemy )
        and npc:character_community() == enemy:character_community()
      )
    then
      if not enemy:alive() then
        if not already_know_about[ npc:id() ][ enemy:id() ] then
          set_sound_event( npc, "dead" )
          already_know_about[ npc:id() ][ enemy:id() ] = true
        end
      elseif IsStalker( enemy ) and xr_wounded.is_wounded( enemy ) then
        if not already_know_about[ npc:id() ][ enemy:id() ] then
          set_sound_event( npc, "fr_hit" )
          already_know_about[ npc:id() ][ enemy:id() ] = true
        end
      end
    end
  else
    return
  end
  if
    enemy:alive()
    and not ( IsStalker( enemy ) and xr_wounded.is_wounded( enemy ) )
  then
    if we_are_under_attack( npc, enemy ) then
      -- человек ты иль монструшка
      -- check_is_enemy( npc, enemy )
      if IsStalker( enemy ) and check_is_enemy( npc, enemy ) then
        register_as_target( npc, enemy )
      elseif IsMonster( enemy ) and check_is_enemy( npc, enemy ) then
        register_as_target( npc, enemy )
      end
    end
  end
end


function we_are_under_attack( npc, enemy )
  if enemy:id() ~= db.actor:id() then
    local target           = enemy:best_enemy()
    local danger_by_engine = enemy:best_danger()
    local best_danger_object, bd_type
    if danger_by_engine and check_is_enemy( npc, enemy ) then
      best_danger_object = danger_by_engine:object()
    end
    if ( not target ) and best_danger_object then
      bd_type = danger_by_engine:type()
      if targeting_dangers[ bd_type ] then
        target = best_danger_object
      end
    end
    if target then
      if
        target:id() == npc:id()
        or (
          IsStalker( target ) and target:alive()
          and (
            npc:relation( target ) == game_object.friend
            or npc:character_community() == target:character_community()
          )
        )
      then
        return true
      else
        return false
      end
    else
      return false
    end
  else
    if check_is_enemy( npc, db.actor ) then
      local be = npc:best_enemy()
      local bd = npc:best_danger()
      local bd_obj
      if bd then
        bd_obj = bd:object()
      end
      if be and be:id() == db.actor:id() then
        return true
      elseif bd_obj and bd_obj:id() == db.actor:id() then
        local bd_type = bd:type()
        if needed_dangers[ bd_type ] then
          return true
        end
      else
        return false
      end
    else
      return false
    end
  end
  return false
end


function is_enemy_see( enemy, npc )
  if enemy:see( npc ) then
    return true
  elseif enemy:is_actor() then
    return actor_see( npc )
  elseif enemy:is_custom_monster() then
    return
      ( enemy:best_enemy() and enemy:best_enemy():id() == npc:id() )
      and true or false
  end
  return false
end


function register_as_target( npc, enemy, force_vis )
  local id = enemy:id()
  if
    ( not targets_list[ npc:id() ] ) or not targets_list[ npc:id() ][ id ]
  then
    if npc and npc:alive() and not xr_wounded.is_wounded(npc) then
      local dist = npc:position():distance_to( enemy:position() )
      local enemy_record = {
        npc    = ( enemy:is_actor() or enemy:is_custom_monster() ),
        range  = dist,
        vis    = ( force_vis or is_enemy_see( enemy, npc ) ),
        weight = 1000,
      }
      if enemy_record.vis and enemy_record.npc then
        enemy_record.last_time_seen = time_global()
        enemy_record.vertex         = enemy:level_vertex_id()
      end
      if not targets_list[ npc:id() ] then
        targets_list[ npc:id() ] = {}
      end
      targets_list[ npc:id() ][ id ] = enemy_record
    else
      return
    end
  end
end


function reprioritize_targets( npc )
  -- обновление основной цели, вызывается из апдейта или любой другой
  -- аналогичной обработки, хоть из эвалуатора
  -- обновим предварительно реестр целей
  if
    last_reprioritize[ npc:id() ]
    and last_reprioritize[ npc:id() ] > time_global()
  then
    return
  end

  get_targets_from_memory( npc )
  refresh_targets( npc )

  if locked_vertexes[ 0 ] then
    local check_hide = locked_vertexes[ 0 ]
    local check_time = bad_hide[ check_hide ]
    if time_global() > check_time then
      bad_hide[ check_hide ] = nil
      locked_vertexes[ 0 ]   = nil
    end
  end

  if total_debug then
    print_table_inlog_v2(
      targets_list[ npc:id() ],
      string.format( "--XRS_BATTLE_AI: TARGS of %s >>", npc:name() )
    )
  end

  local enemy_by_engine = npc:best_enemy()
  for k, v in pairs( targets_list[ npc:id() ] ) do
    if v.vis then               -- если цель видит нас
      local close_combat, far_combat = combat_ranges( npc, v.npc )
      local mult = combat_multiplier( v.npc )
      if not v.npc then         -- если она монстр
        if v.armor then         -- если она пиздец едучий/летячий
          if v.range >= 100 and v.range < 150 then -- и цель далеко
            v.weight = v.range * mult
          elseif v.range < 100 then -- а если близко
            v.weight = v.range * mult * 3
          end
        else
          if v.range >= close_combat and v.range < far_combat then
            -- и цель на средней дистанции
            v.weight = v.range * mult
          elseif v.range < close_combat then -- а если вплотную
            v.weight = v.range * mult -- 0
          elseif check_friends_enemy( npc, k ) then
            v.weight = v.range * mult * 3
          end
        end
      else -- а если непись
        if v.range >= close_combat and v.range < far_combat then
          -- если не ближний бой
          v.weight = v.range
        elseif v.range < close_combat then -- а если ближний
          v.weight = v.range * mult
        elseif v.range > far_combat and v.range < ( npc:range() * 1.5 ) then
          -- сверхдальний бой
          v.weight = v.range * mult * 2
        elseif check_friends_enemy( npc, k ) then
          v.weight = v.range * mult * 3
        end
      end
    else -- если не видит
      if primary_target[ npc:id() ] == k then
        last_target[ npc:id() ][ k ] = time_global()
        primary_target[ npc:id() ] = nil
      end
      if not v.npc then         -- если она монстр
        if v.armor then         -- если она пиздец едучий/летячий
          if v.range < 150 then
            v.weight = v.range * 2
          else
            v.weight = 1000
          end
        else
          if v.range < max_invisible_range_mon then
            v.weight = v.range * 2
          else
            v.weight = 1000
          end
        end
      else                                        -- а если непись
        if v.range < max_invisible_range_npc then -- если в радиусе "слуха"
          v.weight = v.range * 3
        elseif v.range < distant_combat_distance then
          -- если в радиусе дальнего боя
          if
            v.last_time_seen
            and v.last_time_seen + memory_timeout > time_global()
          then
            -- если видели её не менее минуты назад
            v.weight = v.range * 5
          else
            v.weight = 1000
          end
        else
          v.weight = 1000
        end
      end
    end
    if
      enemy_by_engine and enemy_by_engine:alive()
      and not (
        IsStalker( enemy_by_engine )
        and xr_wounded.is_wounded( enemy_by_engine )
      )
      and k == enemy_by_engine:id()
    then
      v.weight = v.weight / 1.3
    end
  end

  local last_range
  local last_weight = 1000
  for k, v in pairs( targets_list[ npc:id() ] ) do
    if v.weight < last_weight then
      last_range  = v.range
      last_weight = v.weight
      primary_target[ npc:id() ] = k
    end
  end

  if not primary_target[ npc:id() ] then
    for k, v in pairs( targets_list[ npc:id() ] ) do
      if v.range < last_weight then
        last_weight = v.range
        if
          v.npc
          and v.range < close_combat_distance
          and v.last_time_seen
          and v.last_time_seen + memory_timeout < time_global()
        then
          last_range = v.range
          primary_target[ npc:id() ] = k
        end
      end
    end
  end
  if last_range then
    last_target[ npc:id() ] = {}
  end

  if primary_target[ npc:id() ] then
    if last_range and last_range > npc:range() then
      npc:set_range( last_range * 1.1 )
    end
    last_reprioritize[ npc:id() ] = time_global() + reprioritize_timeout
  else
    local deadman = have_fresh_deadman( npc )
    if not deadman then
      last_enemy_id[ npc:id()  ] = nil
      primary_target[ npc:id() ] = nil
      last_target[ npc:id()    ] = {}
    end
    last_reprioritize[ npc:id() ] = time_global() + 500
  end
end


function is_armor( target )
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return false end
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli or car then
    return true
  else
    return false
  end
end


function get_armor_vis( target, npc )
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli then
    return target:get_helicopter():isVisible( npc )
  else
    return target:get_car():IsObjectVisible( npc )
  end
end


function armor_alive( target )
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli then
    return target:get_helicopter():GetfHealth() > 0.05
  elseif car then
    return target:get_car():GetfHealth() > 0.05
  end
end


local scheme_name
function get_schema_storage( npc )
  if scheme_name then
    return db.storage[ npc:id() ][ scheme_name ]
  end
end


function refresh_targets( npc )
  -- обновление реестра врагов, вызывается из reprioritize_targets
  -- добавление движкового врага
  local st = get_schema_storage( npc )
  ASSERT( st, "[%s]: %s: storage not found", script_name(), npc:name() )
  local enemy_by_engine = npc:best_enemy()
  if
    enemy_by_engine and enemy_by_engine:alive()
    and (
      not (
        enemy_by_engine:is_stalker()
        and xr_wounded.is_wounded( enemy_by_engine )
      )
    )
    and is_enemy_see( enemy_by_engine, npc )
  then
    if
      ( not targets_list[ npc:id() ][ enemy_by_engine:id() ] )
      and not (
        disabled_objects[ npc:id() ]
        and disabled_objects[ npc:id() ][ enemy_by_engine:id() ]
      )
    then
      if check_is_enemy( npc, enemy_by_engine ) then
        register_as_target( npc, enemy_by_engine )
      else
        disable_object( npc, enemy_by_engine )
        if primary_target[ npc:id() ] == enemy_by_engine:id() then
          last_target[ npc:id() ][ enemy_by_engine:id() ] = time_global()
          primary_target[ npc:id() ] = nil
        end
        targets_list[ npc:id() ][ enemy_by_engine:id() ] = nil
      end
    end
  end

  -- добавление нападающего денжера
  local danger_by_engine = npc:best_danger()
  if danger_by_engine then
    local best_danger_object = danger_by_engine:object()
    if best_danger_object then
      local bd_type = danger_by_engine:type()
      local is_stalker_obj = IsStalker( best_danger_object )
      if is_stalker_obj and check_is_enemy( npc, best_danger_object ) then
        local is_still_alive = best_danger_object:alive()
        if
          is_still_alive and not xr_wounded.is_wounded( best_danger_object )
        then
          if needed_dangers[ bd_type ] then
            if
              ( not targets_list[ npc:id() ][ best_danger_object:id() ] )
              and not (
                disabled_objects[ npc:id() ]
                and disabled_objects[ npc:id() ][ best_danger_object:id() ]
              )
            then
              if check_is_enemy( npc, best_danger_object ) then
                register_as_target( npc, best_danger_object )
              else
                disable_object( npc, best_danger_object )
                if primary_target[ npc:id() ] == best_danger_object:id() then
                  last_target[ npc:id() ][ best_danger_object:id() ] = time_global()
                  primary_target[ npc:id() ] = nil
                end
                targets_list[ npc:id() ][ best_danger_object:id() ] = nil
              end
            end
          end
        end
      end
    end
  end

  for k, v in pairs( targets_list[ npc:id() ] ) do
    local check_target = level.object_by_id( k )
    if
      check_target
      and (
        (
          check_target:alive()
          and not (
            IsStalker( check_target ) and xr_wounded.is_wounded( check_target )
          )
        )
          or ( is_armor( check_target ) and armor_alive( check_target ) )
      )
    then
      if is_armor( check_target ) then
        v.vis = get_armor_vis( check_target, npc )
      else
        v.vis = is_enemy_see( check_target, npc )
      end
      local dist = npc:position():distance_to( check_target:position() )
      v.range = dist
      if not v.vis then
        if not v.npc then
          if v.armor then
            v.vertex = check_target:level_vertex_id()
            if dist > 200 then
              disable_object( npc, check_target )
              if primary_target[ npc:id() ] == k then
                last_target[ npc:id() ][ k ] = time_global()
                primary_target[ npc:id() ] = nil
              end
              targets_list[ npc:id() ][ k ] = nil
            end
          else
            if dist > 100 then
              disable_object( npc, check_target )
              if primary_target[ npc:id() ] == k then
                last_target[ npc:id() ][ k ] = time_global()
                primary_target[ npc:id() ] = nil
              end
              targets_list[ npc:id() ][ k ] = nil
            end
          end
        else
          if check_is_enemy( npc, check_target ) then
            if dist > 100 and k ~= db.actor:id() then
              disable_object( npc, check_target )
              if primary_target[ npc:id() ] == k then
                last_target[ npc:id() ][ k ] = time_global()
                primary_target[ npc:id() ] = nil
              end
              targets_list[ npc:id() ][ k ] = nil
            else
              if npc:see( check_target ) or st.is_camper then
                v.last_time_seen = time_global()
                v.vertex         = check_target:level_vertex_id()
              end
            end
          else
            disable_object( npc, check_target )
            if primary_target[ npc:id() ] == k then
              last_target[ npc:id() ][ k ] = time_global()
              primary_target[ npc:id() ] = nil
            end
            targets_list[ npc:id() ][ k ] = nil
          end
        end
      else
        if v.npc or v.armor then
          v.last_time_seen = time_global()
          v.vertex         = check_target:level_vertex_id()
        end
      end
    elseif check_target then
      if not check_target:alive() then
        set_sound_event( npc, "killed" )
      elseif
        check_target:is_stalker() and xr_wounded.is_wounded( check_target )
      then
        set_sound_event( npc, "hit" )
      end
      disable_object( npc, check_target )
      if primary_target[ npc:id() ] == k then
        last_target[ npc:id() ][ k ] = time_global()
        primary_target[ npc:id() ] = nil
      end
      targets_list[ npc:id() ][ k ] = nil
    else
      if primary_target[ npc:id() ] == k then
        primary_target[ npc:id() ] = nil
        local self_hit = hit()
        self_hit.type      = hit.strike
        self_hit.power     = 0
        self_hit.impulse   = 0.01
        self_hit.draftsman = npc
        self_hit.direction = vector():set( 0, 0, 0 )
        npc:hit( self_hit )
      end
      targets_list[ npc:id() ][ k ] = nil
    end
  end
end


function register_as_target_armor( npc, enemy )
  local id = enemy:id()
  if
    ( not targets_list[ npc:id() ] ) or not targets_list[ npc:id() ][ id ]
  then
    local enemy_record = {
      armor  = true,
      npc    = false,
      range  = npc:position():distance_to( enemy:position() ),
      vis    = false,
      weight = 1000,
    }
    if string.find( enemy:name(), "btr" ) then
      enemy_record.vis = enemy:get_car():IsObjectVisible( npc )
    else
      enemy_record.vis = enemy:get_helicopter():isVisible( npc )
    end
    if enemy_record.vis then
      enemy_record.last_time_seen = time_global()
      enemy_record.vertex         = enemy:level_vertex_id()
    end
    if not targets_list[ npc:id() ] then
      targets_list[ npc:id() ] = {}
    end
    targets_list[ npc:id() ][ id ] = enemy_record
  end
end


function is_hostile_armor( comm, target )
  local t_comm_number = 1
  local t_comm        = "actor"
  if
    string.find( target:section(), "helicopter" )
    or string.find( target:section(), "mi24" )
    or string.find( target:section(), "mi2"  )
    or string.find( target:section(), "mi6"  )
  then
    if target:spawn_ini():line_exist( "logic", "community" ) then
      t_comm = ini:r_string( "logic", "community" )
    else
      t_comm = "military"
    end
  elseif string.find( target:name(), "btr" ) then
    local check_comm -- = ogse_scripted_btr.cars_comm[target:name()]
    if not check_comm then
      t_comm = "military"
    end
  end
  local hostile_treshold = tonumber(
    system_ini():r_string( "game_relations", "attitude_neutal_threshold" )
  )
  local comm_attitude    = parse_data(
    system_ini():r_string( "communities_relations", comm )
  )
  local comm_list        = parse_data(
    system_ini():r_string( "game_relations", "communities" )
  )
  for k, v in pairs ( comm_list ) do
    if t_comm == tostring( v ) then
      t_comm_number = ( k + 1 ) / 2
      break
    end
  end
  local attitude = tonumber( comm_attitude[ t_comm_number ] ) or -5000
  -- квестовая врезка начало
  if
    level.name() == "l13_generators_ogse"
    and (
      string.find( target:section(), "helicopter" )
      or string.find( target:section(), "mi24" )
    )
    and ( comm == "freedom" or comm == "dolg" )
  then
    return false
  end
  -- квестовая врезка конец
  return attitude < hostile_treshold
end


function check_helicopter( npc )
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return end
  local npc_position = npc:position()
  for k, v in pairs( db.heli ) do
    local heli   = v:get_helicopter()
    local health = heli:GetfHealth()
    if health < 0 then
      health = 0
    end
    if
      health > 0.005
      and v:position():distance_to( npc_position ) <= 150
      and is_hostile_armor( npc:character_community(), v )
    then
      register_as_target_armor( npc, v )
    end
  end
end


function check_btr(npc)
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return end
  local npc_position = npc:position()
  for k, v in pairs( db.cars ) do
    if string.find( v:name(), "btr" ) then
      local btr    = v:get_car()
      local health = btr:GetfHealth()
      if health < 0 then
        health = 0
      end
      if
        health > 0.005
        and v:position():distance_to( npc_position ) <= 150
        and is_hostile_armor( npc:character_community(), v )
      then
        register_as_target_armor( npc, v )
      end
    end
  end
end


function get_targets_from_memory( npc )
  -- сбор врагов, вызывается из reprioritize_targets
  check_helicopter( npc )
  check_btr( npc )
  for o in npc:memory_visible_objects() do
    process_enemy( npc, o:object() )
  end
  for o in npc:memory_sound_objects() do
    process_enemy( npc, o:object() )
  end
  local mem = hit_memory[ npc:id() ]
  if mem then
    for k, v in pairs( mem ) do
      local enemy = level.object_by_id( k )
      if enemy and IsStalker( enemy ) and enemy:alive() then
        process_enemy( npc, enemy )
      end
    end
  end
end


function get_max_weapon_range( npc, bw )
  -- служебная для проверки достанет ли оружие
  if npc then
    if not bw then bw = get_best_weapon( npc ) end
    local ini = system_ini()
    if bw then
      local sect = bw:section()
      if ini:section_exist( sect ) and ini:line_exist( sect, "max_radius" ) then
        return ini:r_float( sect, "max_radius" )
      elseif not ini:section_exist( sect ) then
        return 36
      elseif not ini:line_exist( sect, "max_radius" ) then
        return 36
      end
    else
      return 36
    end
  else
    return 36
  end
end


function combat_ranges( npc, enemy_is_npc )
  if npc then
    local wpn_check_max_range = get_max_weapon_range( npc )
    -- берем всех
    if enemy_is_npc then
      return low_range_npc_aggr, wpn_check_max_range
    else
      return low_range_mon_aggr, far_range_mon_aggr
    end
  else
    return 30, alife():switch_distance()
  end
end


function combat_multiplier( enemy_is_npc )
  if enemy_is_npc then
    return combat_mult_npc
  else
    return combat_mult_monster
  end
end


function have_fresh_deadman( npc )
  if not last_target[ npc:id() ] then return false end
  local t = last_target[ npc:id() ]
  local targets = {}
  for k, v in pairs( t ) do
    local obj     = level.object_by_id( k )
    local timeout = remember_enemy
    if obj and ( obj:is_actor() or obj:is_stalker() ) then
      timeout = timeout * 2
    end
    if not obj then
      t[ k ] = nil
    elseif not ( obj:is_actor() or obj:is_custom_monster() )  then
      t[ k ] = nil
    elseif v + timeout > time_global() then
      table.insert( targets, k )
    else
      t[ k ] = nil
    end
  end
  if table.getn( targets ) > 0 then
    table.sort( targets, function( a, b ) return t[ a ] > t[ b ] end )
    return targets[ 1 ]
  end
  return false
end


-- Алгоритм озвучки: неперывно собираем информацию про звуковые
-- события. Если есть событие - расскажем о нем. Если нет события
-- врубаем айдл

-- Айдлы ставятся флагами и разворачиваются по ситуации. Те что
-- ставятся флагами это Атакуем, Защищаемся, Не видим противника.

-- Атакуем разворачивается в: Атакуем (видим и он нас видит), Атакуем
-- одного/Атакуем группу (видим и он нас НЕ видит)

-- Защищаемся не разворачивается

-- Не видим противника разворачивается в: Грозим близкому врагу/Грозим
-- далекому врагу (зависимо от расстояния, время потери до 10 секунд),
-- Ищем врага (от 10 до 20 секунд), Совсем потеряли врага (более 20
-- секунд)

-- Ставятся они в выброе типа перемещения, разворачивание производится
-- на основе таблицы целей

-- События добываются следующим образом:
-- Начало боя из старта боёвки
-- Идем в обход из выбора перемещения
-- Завалили врага из refresh_targets(npc), если цель погибла
-- Ранили врага из refresh_targets(npc), если цель ранена
-- Ранило друга из get_targets_from_memory(npc), если есть раненый
-- друг и мы его видим
-- Убило друга из get_targets_from_memory(npc), если есть убитый друг
-- и мы его видим
-- Френдли файр из хит коллбэка

-- События которые надо отыграть звуком
-- 1. Начало боя            fight_enemy
-- 2. Идем в обход          fight_detour
-- 3. Завалили врага        fight_enemy_down
-- 4. Ранили врага          fight_enemy_hit
-- 5. Ранило друга          fight_friend_hitted
-- 6. Убило друга           fight_tolls
-- 7. Френдли файр          fight_friendly_fire

-- Боевочные идлы
-- 1. Атакуем               fight_attack
-- 2. Атакуем одного        fight_attack_one
-- 3. Атакуем группу        fight_attack_many
-- 4. Защищаемся            fight_backup
-- 5. Ищем врага            fight_search
-- 6. Совсем потеряли врага fight_enemy_lost
-- 7. Грозим близкому врагу fight_threat_close
-- 8. Грозим далекому врагу fight_threat_distant

-- Функции: set_sound_event( npc, event ) -- выставить звуковое событие
-- допустимые значения event:
-- "start"
-- "hero"
-- "killed"
-- "hit"
-- "fr_hit"
-- "dead"
-- "ff"

-- choose_idle_scheme( npc, scheme ) -- выставить тип идловой озвучки
-- допустимые значеня scheme:
-- "attack"
-- "attack_notsee"
-- "defence"
-- "lost"

function setup_sound_table( npc )
  sound_events[ npc:id() ] = {
    events = {},
    idle   = "defence",
    start  = false,
    hero   = false,
    killed = false,
    hit    = false,
    fr_hit = false,
    dead   = false,
    ff     = false,
  }
end


function choose_idle_scheme( npc, scheme )
  -- допустимые значеня scheme:
  -- "attack"
  -- "attack_notsee"
  -- "defence"
  -- "lost"
  if not sound_events[ npc:id() ] then
    setup_sound_table( npc )
  end
  sound_events[ npc:id() ].idle = scheme
end


function set_sound_event( npc, event )
  if not sound_events[ npc:id() ] then
    setup_sound_table( npc )
  end
  -- Если недавно что-то уже говорил, то событие регистрировать не
  -- будем.
  if sounds_timeout[ npc:id() ] and sounds_timeout[ npc:id() ] > time_global() then
    return
  end
  local t = sound_events[ npc:id() ]
  -- Если это событие запрещено некоторе время озвучивать, то
  -- регистрировать его не будем.
  local e_timeout = t[ event .. "_timeout" ]
  if e_timeout and e_timeout > time_global() then return end
  if not t[ event ] then
    if event == "hero" then
      t.hero_timeout = time_global() + math.random( 10000, 30000 )
      if math.random() > sound_prob_hero then return end
    end
    t[ event ] = true
    table.insert( t.events, event );
  end
end


function set_combat_sound_playing( npc )
  sound_are_playing[ npc:id() ] = time_global() + math.random( 1000, 2500 )
end


function set_combat_sound_timeout( npc )
  sounds_timeout[ npc:id() ] = time_global() + math.random( 6000, 8000 )
end


function process_combat_sound( npc )
  if
    sound_are_playing[ npc:id() ]
    and sound_are_playing[ npc:id() ] > time_global()
  then
    return
  elseif sound_are_playing[ npc:id() ] then
    sound_are_playing[ npc:id() ] = nil
    xr_sound.set_sound( npc, nil )
    return
  end
  if
    sounds_timeout[ npc:id() ]
    and sounds_timeout[ npc:id() ] > time_global()
  then
    return
  end

  local snd_flags = sound_events[ npc:id() ]
  if table.getn( snd_flags.events ) > 0 then
    local e = snd_flags.events[ math.random( table.getn( snd_flags.events ) ) ]
    for _, k in ipairs( snd_flags.events ) do
      snd_flags[ k ] = false
    end
    snd_flags.events = {}
    if math.random() < sound_prob_event then
      local snd_theme
      if e == "start" then
        snd_theme = "fight_enemy"
      elseif e == "dead" then
        snd_theme = "fight_tolls"
      elseif e == "fr_hit" then
        snd_theme = "fight_friend_hitted"
      elseif e == "ff" then
        snd_theme = "fight_friendly_fire"
      elseif e == "killed" then
        snd_theme = "fight_enemy_down"
      elseif e == "hit" then
        snd_theme = "fight_enemy_hit"
      elseif e == "hero" then
        snd_theme = "fight_detour"
      end
      xr_sound.set_sound_play( npc, snd_theme )
      set_combat_sound_playing( npc )
      set_combat_sound_timeout( npc )
      return
    end
  end

  if
    snd_flags.idle_timeout
    and snd_flags.idle_timeout > time_global()
  then
    return
  end
  snd_flags.idle_timeout = time_global() + math.random( 10000, 30000 )
  if math.random() > sound_prob_idle then return end

  set_combat_sound_playing( npc )
  set_combat_sound_timeout( npc )
  if snd_flags.idle == "attack" then
    xr_sound.set_sound_play( npc, "fight_attack" )
  elseif snd_flags.idle == "attack_notsee" then
    local count = 0
    for k, v in pairs( targets_list[ npc:id() ] ) do
      if v.range < 50 then
        count = count + 1
      end
      if count >= 2 then
        break
      end
    end
    if count == 1 then
      xr_sound.set_sound_play( npc, "fight_attack_one" )
    elseif count > 1 then
      xr_sound.set_sound_play( npc, "fight_attack_many" )
    end
  elseif snd_flags.idle == "defence" then
    xr_sound.set_sound_play( npc, "fight_backup" )
  elseif snd_flags.idle == "lost" then
    local target = primary_target[ npc:id() ]
    local target_info = targets_list[ npc:id() ][ target ]
    if not target_info then return end
    if target_info and not target_info.last_time_seen then
      if math.random() < 0.2 then
        xr_sound.set_sound_play( npc, "fight_threat_close" )
      elseif math.random() < 0.4 then
        xr_sound.set_sound_play( npc, "fight_threat_distant" )
      elseif math.random() < 0.6 then
        xr_sound.set_sound_play( npc, "fight_search" )
      else
        xr_sound.set_sound_play( npc, "fight_enemy_lost" )
      end
      return
    end
    if time_global() - target_info.last_time_seen <= 5000 then
      if target_info.range < distant_combat_distance then
        xr_sound.set_sound_play( npc, "fight_threat_close" )
      else
        xr_sound.set_sound_play( npc, "fight_threat_distant" )
      end
    elseif time_global() - target_info.last_time_seen <= 12000 then
      xr_sound.set_sound_play( npc, "fight_search" )
    else
      xr_sound.set_sound_play( npc, "fight_enemy_lost" )
    end
  end
end


-- Возвращает угол между проекциями векторов vec1 и vec2 на
-- горизонтальную плоскость.
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle( vec1, vec2 )
  local x =  vec2.x * vec1.x + vec2.z * vec1.z
  -- повернули систему координат
  local y = -vec2.z * vec1.x + vec2.x * vec1.z
  return math.atan2( y, x )     -- угол доворота от -pi до pi
end


function actor_see( npc )
  -- арктангенс 45 град /npc:position():distance_to(db.actor:position())
  local dangerang = 1
  local ang = horz_angle(
    device().cam_dir, npc:position():sub( device().cam_pos )
  )
  local visibility_value = level.cover_in_direction(
    db.actor:level_vertex_id(), npc:position():sub( db.actor:position() )
  )
  local tgt = ang > -dangerang and ang < dangerang
    and visibility_value > visibility_treshold_value
  if tgt then
    return true
  end
  return false
end


function get_target( npc )
  local target_id = primary_target[ npc:id() ]
  local target
  if target_id then
    target = level.object_by_id( target_id )
  end
  return target
end


function IsShotgun( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 7
  end
  return false
end


function IsSniperRifle( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 8
  end
  return false
end


function IsRPG( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 9
  end
  return false
end


function in_hideout( npc )
  local t = last_hideout[ npc:id() ]
  if t and ( npc:level_vertex_id() == t.vtx or npc:path_completed() ) then
    return true
  end
  return false
end


function in_transit( npc )
  local vertex = last_sent_vertex[ npc:id() ]
  if
    vertex and npc:level_vertex_id() ~= vertex and not npc:path_completed()
  then
    return true
  end
  return false
end


function action_altcombat:set_weapons_fire( enemy, weapon, override_vis, npc_rank )
  if not (
    enemy
    and ( enemy:alive() or ( is_armor( enemy ) and armor_alive( enemy ) ) )
    and weapon
    and not ( enemy:is_stalker() and xr_wounded.is_wounded( enemy ) )
  ) then
    return
  end

  local npc          = self.object
  local time_aim     = time_to_aim[ npc_rank ]
  local type_of_fire = object.aim1

  local be_pos = enemy:position()
  local st     = self.combat_sight
  if st and st.look_pos then
    be_pos = st.look_pos
  end

  local npc_pos  = vector():set( 0, 0, 0 )
  local npc_dir  = vector():set( 0, 0, 0 )
  npc:g_fireParams( weapon, npc_pos, npc_dir )
  local distance = npc_pos:distance_to( be_pos )

  local rq = npc:see_right_now( enemy )
  if is_armor( enemy ) and armor_alive( enemy ) then
    rq           = false
    type_of_fire = object.fire1
  else
    local weapon_unstrapped = npc:weapon_unstrapped()
    if
      ( not weapon_unstrapped ) or ( IsRPG( weapon ) and distance < 25 )
    then
      rq           = false
      type_of_fire = object.aim1
    end
  end

  if rq then
    rq = level.ray_query(
      npc_pos, npc_dir, distance + 5, rq_target.rqtBoth, npc
    )
    type_of_fire = object.fire1 -- по умолчанию можем стрелять
    if rq.result then
      local obj = rq.object
      local is_alive_mob = obj and ( obj:is_actor() or obj:is_custom_monster() )
        and obj:alive()
      if is_alive_mob and not check_is_enemy( npc, obj, true ) then
        -- если попадем в своего - стрелять нельзя
        type_of_fire = object.aim1
      end
    end
  end

  if type_of_fire == object.fire1 then
    if distance > 0 and st and st.use_deviation then
      self:add_deviation( be_pos, weapon, distance, enemy )
    else
      npc:stalker_disp_base( 0 )
    end
  end

  if IsShotgun( weapon ) or IsSniperRifle( weapon ) then
    npc:set_item( type_of_fire, weapon, 1, time_aim.other )
  elseif IsRPG( weapon ) then
    npc:set_item( type_of_fire, weapon, 1, time_aim.rpg )
  else
    local qs = get_u32(
      weapon:section(), "xrs_battle_ai.preffered_fire_mode"
    )
    if not qs then
      qs = math.random( 2, 5 )
    end
    npc:set_item( type_of_fire, weapon, qs, time_aim.other )
  end
end


function action_altcombat:set_combat_state( enemy, weapon )
  local npc = self.object
  npc:set_mental_state( anim.danger )
  if in_hideout( npc ) then
    npc:set_movement_type( move.stand )
    local hide_val = last_hideout[ npc:id() ].value
    if hide_val <= 0.45 then
      npc:set_body_state( move.crouch )
    else
      npc:set_body_state( move.standing )
    end
  elseif in_transit( npc ) then
    npc:set_movement_type( move.walk )
    npc:set_body_state( move.standing )
  else
    npc:set_movement_type( move.stand )
    local npc_pos  = npc:position()
    local be_pos   = enemy:position()
    local distance = be_pos:distance_to( npc_pos )
    if distance < close_combat_distance then
      npc:set_body_state( move.standing )
    else
      npc:set_body_state( move.crouch )
    end
  end
end


function action_altcombat:set_transfer_state( enemy, sight )
  local npc = self.object
  npc:set_mental_state( anim.danger )
  if in_hideout( npc ) then
    npc:set_movement_type( move.stand )
    local hide_val = last_hideout[ npc:id() ].value
    if hide_val <= 0.45 then
      npc:set_body_state( move.crouch )
    else
      npc:set_body_state( move.standing )
    end
  elseif in_transit( npc ) then
    if sight then
      npc:set_sight( look.path_dir, true, true )
    end
    npc:set_movement_type( move.run )
    npc:set_body_state( move.standing )
  else
    npc:set_movement_type( move.stand )
    npc:set_body_state( move.standing )
  end
end


function action_altcombat:add_deviation( position, weapon, distance, enemy )
  local npc        = self.object
  local npc_rank   = get_obj_rank_name( npc )
  local npc_comm   = npc:character_community()
  local deviations = deviation_table[ npc_rank ]
  local dev_coeff  = community_deviation_coeff[ npc_comm ]
    or community_deviation_coeff.stalker
  local max = 0
  if deviations then
    max = deviations * dev_coeff
    if enemy:is_actor() then
      local k = 1 - inventory.on_belt_hit_immunity( "fire_wound_immunity" )
      if k > 0 then
        max = max * k
      else
        max = 0
      end
      self.firing_actor = true
      if self.start_firing_actor then
        local time = time_global() - self.start_firing_actor
        local k    = 1 - ( time / firing_actor_disp_time )
        if k > 0 then
          local min_max = firing_actor_disp_max - firing_actor_disp_min
          max = max * ( firing_actor_disp_min + min_max * k )
        else
          max = max * firing_actor_disp_min
        end
      else
        self.start_firing_actor = time_global()
        max = max * firing_actor_disp_max
      end
    end
  end
  npc:stalker_disp_base( distance, max )
end


function action_altcombat:set_combat_sight( enemy, weapon )
  local npc = self.object
  if not weapon then
    npc:set_sight( enemy, true, true )
    return
  end

  local enemy_pos = enemy:position()
  local npc_pos   = npc:position()
  local distance  = npc_pos:distance_to( enemy_pos )

  local st = self.combat_sight
  if not st then
    st = {}
    self.combat_sight = st
  end

  local bone
  if
    st.bone
    and st.enemy_id == enemy:id() and st.weapon_id == weapon:id()
    and st.time > time_global()
  then
    bone = st.bone
  else
    local use_deviation = true
    if enemy:is_actor() or enemy:is_stalker() then
      use_deviation = not IsSniperRifle( weapon )
      local rank = get_obj_rank_name( npc )
      if math.random() < headshot_prob[ rank ] then
        local bones = { "bip01_head", "bip01_neck" }
        bone = bones[ math.random( table.getn( bones ) ) ]
      end
    elseif enemy:is_monster() then
      use_deviation = false
    end
    st.bone      = bone
    st.enemy_id  = enemy:id()
    st.time      = time_global() + 10000
    st.use_deviation = use_deviation
    st.weapon_id = weapon:id()
  end

  local look_pos
  if bone then
    local bone_id = enemy:get_bone_id( bone )
    ASSERT(
      bone_id ~= 65535,
      "[%s]: %s: unknown bone %s", script_name(), enemy:name(), bone
    )
    look_pos = enemy:bone_position( bone )
  end

  if
    ( not npc:see( enemy ) )
    and npc:memory_position( enemy ):magnitude() ~= 0
  then
    look_pos = npc:memory_position( enemy )
  end

  st.look_pos = look_pos
  npc:set_desired_direction()
  if look_pos then
    npc:set_sight( look.fire_point, look_pos )
  else
    npc:set_sight( enemy, true, true )
  end
end


function check_vertex_locked( npc, vertex )
  if locked_vertexes[ 0 ] and locked_vertexes[ 0 ] == vertex then
    return true
  end
  local vertex_pos = level.vertex_position( vertex )
  for k, v in pairs( locked_vertexes ) do
    local loced_vtx_pos = level.vertex_position( v )
    if
      k ~= npc:id()
      and ( v == vertex or vertex_pos:distance_to( loced_vtx_pos ) < 2 )
    then
      local checking_npc = level.object_by_id( k )
      if checking_npc and checking_npc:alive() then
        return true
      end
    end
  end
  return false
end


-- список режимов:
-- mode = 0 - оборона (удержание позиции)
-- mode = 1 - атака
-- mode = 2 - отступление
function find_cover( npc, enemy, mode, camper_vertex )
  -- возвращает лучшую точку прикрытия от врага в заданном радиусе от
  -- своей позиции и на нужном расстояниии от врага
  -- cover_point* best_cover(vector self_position, vector enemy_position, float radius, float min_enemy_distance, float max_enemy_distance)
  --
  -- возвращает лучшую точку прикрытия в заданном радиусе от своей
  -- позиции и не ближе min_distance. Прикрытость учитывается со всех
  -- направлений.
  -- cover_point* safe_cover(const vector& self_position, float radius, float min_distance)
  --
  -- C++ class cover_point {
  --   function level_vertex_id() const;
  --   function position() const;
  -- };

  if last_time_send[ npc:id() ] and not npc:path_completed() then
    return 0
  end
  if not ( npc and enemy ) then return end

  local enemy_pos    = enemy:position()
  local enemy_vertex = enemy:level_vertex_id()
  local npc_pos      = npc:position()
  local to_enemy     = npc_pos:distance_to( enemy_pos )

  local cover_cache    = {}
  local cover_callback = function( cover, next_check )
    local cover_vertex = cover:level_vertex_id()
    local cached       = cover_cache[ cover_vertex ]
    if cached ~= nil then return cached end
    cover_cache[ cover_vertex ] = not (
      check_vertex_locked( npc, cover_vertex )
      or its_a_trap( npc, cover_vertex )
      or ( next_check and next_check( cover ) )
      or false
    )
    return cover_cache[ cover_vertex ]
  end

  local cover, cover_vertex
  local min_dist = close_combat_distance
  if mode == 1 then             -- атака по дуге
    local max = math.max( to_enemy, min_dist )
    local min = min_dist
    cover_cache = {}
    if to_enemy - min > 0 then
      cover = npc:angle_cover(
        npc_pos, to_enemy, enemy_pos, min, max, enemy_vertex, cover_callback
      )
    end
    if not cover then
      for _, r in ipairs({ 10, 30 }) do
        cover = npc:angle_cover(
          npc_pos, r, enemy_pos, min, max, enemy_vertex, cover_callback
        )
        if cover then break end
      end
    end

  elseif mode == 2 then         -- отступление
    cover_cache = {}
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:best_cover(
        npc_pos, enemy_pos, r, to_enemy, to_enemy + r, cover_callback
      )
      if cover then break end
    end

  elseif mode == 3 then         -- атака
    cover_cache = {}
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:ambush_cover(
        npc_pos, enemy_pos, r, close_combat_distance, cover_callback
      )
      if cover then break end
    end

  elseif mode == 4 then         -- атака
    cover_cache = {}
    for _, r in ipairs({ 10, 30 }) do
      local max = math.max( to_enemy, min_dist )
      local min = min_dist
      cover = npc:best_cover(
        npc_pos, enemy_pos, r, min, max, cover_callback
      )
      if cover then break end
    end

  elseif mode == 5 then         -- возврат кемпера на точку
    cover_vertex = camper_vertex

  elseif mode == 6 then -- срочное отступление, противник очень близко
    cover_cache = {}
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:best_cover(
        npc_pos, enemy_pos, r, to_enemy + 5, to_enemy + r,
        function( cover )
          return cover_callback(
            cover,
            function( cover )
              local pos = cover:position()
              return pos:distance_to( npc_pos ) > pos:distance_to( enemy_pos )
            end
          )
        end
      )
      if cover then break end
    end

  elseif mode == 7 then         -- отступление по дуге
    cover_cache = {}
    cover = npc:angle_cover(
      npc_pos, to_enemy, enemy_pos, to_enemy, to_enemy * 2, enemy_vertex,
      cover_callback
    )
    if not cover then
      for _, r in ipairs({ 10, 30 }) do
        cover = npc:best_cover(
          npc_pos, enemy_pos, r, to_enemy, to_enemy + r, cover_callback
        )
        if cover then break end
      end
    end

  elseif mode == 0 then         -- оборона
    cover_cache = {}
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:safe_cover( npc_pos, r, 0, cover_callback )
      if cover then break end
    end
  end

  local cover_pos
  if cover then
    cover_pos    = cover:position()
    cover_vertex = cover:level_vertex_id()
  elseif cover_vertex then
    cover_pos    = level.vertex_position( cover_vertex )
    cover_value = 0
  else
    return
  end
  local cover_value = level.cover_in_direction(
    cover_vertex, enemy_pos:sub( cover_pos )
  )

  last_time_send[ npc:id()   ] = time_global()
  last_sent_vertex[ npc:id() ] = cover_vertex
  last_hideout[ npc:id()     ] = {
    value = cover_value,
    vtx   = cover_vertex,
  }
  locked_vertexes[ npc:id() ] = cover_vertex

  return cover_vertex
end


function is_exclusion( npc )
  local name    = npc:name()
  local profile = npc:profile_name()
  if
    string.find( name, "prisoner" ) or string.find( profile, "prisoner" )
    or string.find( name, "captive" ) or string.find( profile, "captive" )
    or string.find( name, "esc_shustryi" )
  then
    return true
  else
    return false
  end
end


evid_altcombat  = 18720
actid_altcombat = evid_altcombat + 1

function add_to_binder( object, ini, scheme, section, storage )
  local operators  = {
    [ "gogogo" ] = actid_altcombat,
  }
  local properties = {
    [ "alt_combat_enabled" ] = evid_altcombat,
  }

  local manager = object:motivation_action_manager()
  local property_wounded         = xr_evaluators_id.sidor_wounded_base
  local state_mgr_to_idle_combat = xr_actions_id.state_mgr + 1
  local state_mgr_to_idle_alife  = xr_actions_id.state_mgr + 2

  local lname = level.name()
  local comm  = object:character_community()
  local forbidden_by_comm = community_forbidden_locations[ comm ]
  if
    ( not object:alive() )
    or forbidden_comms[ comm ]
    or ( forbidden_by_comm and forbidden_by_comm[ lname ] )
    or forbidden_by_lname[ lname ]
    or forbidden_profiles[ object:name() ]
    or forbidden_profiles[ object:profile_name() ]
    or (
      comm == "monolith"
      and string.find( object:name(), "pri_" )
      and (
        string.find( object:name(), "sniper" )
        or string.find( object:name(), "roof" )
      )
    )
  then
    manager:add_evaluator(
      properties.alt_combat_enabled, property_evaluator_const( false )
    )
    return
  end

  manager:add_evaluator(
    properties.alt_combat_enabled,
    evaluator_check_altcombat( "alt_combat_enabled", storage )
  )

  local action = action_altcombat( object, "gogogo", storage )
  action:add_precondition( world_property( stalker_ids.property_alive, true ) )
  action:add_precondition(
    world_property( xr_evaluators_id.sidor_wounded_base, false )
  )
  xrs_ai.addCommonPrecondition( action )
  action:add_precondition(
    world_property( blowout_scheme.evid_outside, false )
  )
  action:add_precondition(
    world_property( blowout_scheme.evid_blowout, false )
  )
  action:add_precondition(
    world_property( blowout_scheme.evid_preblowout, false )
  )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, true )
  )
  action:add_effect( world_property( properties.alt_combat_enabled, false ) )
  action:add_effect( world_property( stalker_ids.property_enemy, false ) )
  manager:add_action( operators.gogogo, action )

  action = manager:action( stalker_ids.action_combat_planner )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( stalker_ids.action_alife_planner )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( state_mgr_to_idle_alife )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( state_mgr_to_idle_combat )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( stalker_ids.action_hide_from_grenade )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( stalker_ids.action_reach_wounded_enemy )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )
end


function enable_scheme( npc, ini, scheme, section )
  scheme_name = scheme
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
end


function disable_scheme( npc, scheme )
  local st = db.storage[ npc:id() ][ scheme ]
  if st then
    st.enabled = false
  end
end
