-- -*- mode: lua; coding: windows-1251-dos -*-

class "covers_mgr"
function covers_mgr:__init( act, be )
  self.act    = act
  self.be     = be
  self.object = act.object
  self.st     = act.st
end

function covers_mgr:find_cover_0()
  return self:find_cover( 0 )
end

function covers_mgr:find_cover_1()
  return self:find_cover( 1 )
end

function covers_mgr:find_cover_2()
  return self:find_cover( 2 )
end

function covers_mgr:find_cover_3()
  return self:find_cover( 3 )
end

function covers_mgr:find_cover_4()
  return self:find_cover( 4 )
end

function covers_mgr:find_cover_5()
  return self:find_cover( 5 )
end

function covers_mgr:find_cover_6()
  return self:find_cover( 6 )
end

function covers_mgr:find_cover_7()
  return self:find_cover( 7 )
end

function covers_mgr:find_cover_8()
  return self:find_cover( 8 )
end

function covers_mgr:find_cover_9()
  return self:find_cover( 9 )
end

function covers_mgr:grenade()
  return 0
end

function covers_mgr:keep()
  return 0
end

-- список режимов:
-- mode = 0 - оборона (удержание позиции)
-- mode = 1 - атака
-- mode = 2 - отступление
function covers_mgr:find_cover( mode )
  local enemy = self.be
  local npc   = self.object

  -- возвращает лучшую точку прикрытия от врага в заданном радиусе от
  -- своей позиции и на нужном расстояниии от врага
  -- cover_point* best_cover(vector self_position, vector enemy_position, float radius, float min_enemy_distance, float max_enemy_distance)
  --
  -- возвращает лучшую точку прикрытия в заданном радиусе от своей
  -- позиции и не ближе min_distance. Прикрытость учитывается со всех
  -- направлений.
  -- cover_point* safe_cover(const vector& self_position, float radius, float min_distance)
  --
  -- C++ class cover_point {
  --   function level_vertex_id() const;
  --   function position() const;
  -- };

  if last_time_send[ npc:id() ] and not npc:path_completed() then
    return 0
  end
  if not ( npc and enemy ) then return end

  local enemy_pos    = enemy:position()
  local enemy_vertex = enemy:level_vertex_id()
  local npc_pos      = npc:position()
  local to_enemy     = npc_pos:distance_to( enemy_pos )

  local cover_cache    = cover_cache_processor( npc, enemy )
  local cover_callback = function( cover, next_check )
    return cover_cache:callback( cover, next_check )
  end

  local cover, cover_vertex
  local min_dist = close_combat_distance
  if mode == 1 then             -- атака по дуге
    local max = math.max( to_enemy, min_dist )
    local min = min_dist
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:angle_cover(
        npc_pos, r, enemy_pos, min, max, enemy_vertex, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( true, cover_cache:get_cache() )
    end

  elseif mode == 2 then         -- отступление
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:best_cover(
        npc_pos, enemy_pos, r, to_enemy, to_enemy + r, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( false, cover_cache:get_cache() )
    end

  elseif mode == 3 then         -- атака
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:ambush_cover(
        npc_pos, enemy_pos, r, close_combat_distance, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( true, cover_cache:get_cache() )
    end

  elseif mode == 4 then         -- атака
    for _, r in ipairs({ 10, 30 }) do
      local max = math.max( to_enemy, min_dist )
      local min = min_dist
      cover = npc:best_cover(
        npc_pos, enemy_pos, r, min, max, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( true, cover_cache:get_cache() )
    end

  elseif mode == 5 then         -- возврат кемпера на точку
    cover_vertex = self.st.is_camper

  elseif mode == 6 then -- срочное отступление, противник очень близко
    cover_vertex = self:find_pseudo_cover( false, cover_cache:get_cache() )

  elseif mode == 7 then         -- отступление по дуге
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:best_cover(
        npc_pos, enemy_pos, r, to_enemy, to_enemy + r, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( false, cover_cache:get_cache() )
    end

  elseif mode == 8 then         -- максимальное приближение к противнику
    local min_dist = npc:radius() + enemy:radius() + 5
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:close_cover(
        npc_pos, enemy_pos, r, min_dist, 300, 10, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( true, cover_cache:get_cache() )
    end

  elseif mode == 9 then         -- максимальное удаление от противника
    local min_dist = npc:radius() + enemy:radius() + 5
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:far_cover(
        npc_pos, enemy_pos, r, min_dist, 300, 10, cover_callback
      )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
    if not cover then
      cover_vertex = self:find_pseudo_cover( false, cover_cache:get_cache() )
    end

  elseif mode == 0 then         -- оборона
    for _, r in ipairs({ 10, 30 }) do
      cover = npc:safe_cover( npc_pos, r, 0, cover_callback )
      if cover then break end
    end
    cover = cover_cache:best_cover( cover )
  end

  local cover_pos
  if cover then
    cover_pos    = cover:position()
    cover_vertex = cover:level_vertex_id()
  elseif cover_vertex then
    cover_pos    = level.vertex_position( cover_vertex )
    cover_value = 0
  else
    return
  end
  local cover_value = level.cover_in_direction(
    cover_vertex, enemy_pos:sub( cover_pos )
  )

  last_time_send[ npc:id()   ] = time_global()
  last_sent_vertex[ npc:id() ] = cover_vertex
  last_hideout[ npc:id()     ] = {
    value = cover_value,
    vtx   = cover_vertex,
  }
  lock_vertex( npc, cover_vertex )

  return cover_vertex
end


function covers_mgr:find_pseudo_cover( attack, cover_cache )
  local enemy = self.be
  local npc   = self.object
  if not cover_cache then cover_cache = {} end
  local dir = vector():sub( enemy:position(), npc:position() )
  local rotate_min, rotate_max
  if attack then
    rotate_min, rotate_max =  0,  90
  else
    rotate_min, rotate_max = 45, 180
  end
  local min_dist, max_dist = close_combat_distance, close_combat_distance
  local node_1_vertex_id = find_vertex_around(
    npc, npc:level_vertex_id(), dir, rotate_min, rotate_max,
    min_dist, max_dist,  1, cover_cache
  )
  local node_2_vertex_id = find_vertex_around(
    npc, npc:level_vertex_id(), dir, rotate_min, rotate_max,
    min_dist, max_dist, -1, cover_cache
  )
  if node_1_vertex_id and node_2_vertex_id then
    local pos   = npc:position()
    local dist1 = pos:distance_to( level.vertex_position( node_1_vertex_id ) )
    local dist2 = pos:distance_to( level.vertex_position( node_2_vertex_id ) )
    if dist1 > dist2 then
      return node_1_vertex_id
    elseif dist2 > dist1 then
      return node_2_vertex_id
    else
      return random_choice( node_1_vertex_id, node_2_vertex_id )
    end
  elseif node_1_vertex_id then
    return node_1_vertex_id
  elseif node_2_vertex_id then
    return node_2_vertex_id
  else
    node_1_vertex_id = find_vertex_around(
      npc, npc:level_vertex_id(), dir, 0, 360,
      min_dist, max_dist,  1, cover_cache
    )
    node_2_vertex_id = find_vertex_around(
      npc, npc:level_vertex_id(), dir, 0, 360,
      min_dist, max_dist, -1, cover_cache
    )
    if node_1_vertex_id and node_2_vertex_id then
      local pos   = npc:position()
      local dist1 = pos:distance_to( level.vertex_position( node_1_vertex_id ) )
      local dist2 = pos:distance_to( level.vertex_position( node_2_vertex_id ) )
      if dist1 > dist2 then
        return node_1_vertex_id
      elseif dist2 > dist1 then
        return node_2_vertex_id
      else
        return random_choice( node_1_vertex_id, node_2_vertex_id )
      end
    elseif node_1_vertex_id then
      return node_1_vertex_id
    else
      return node_2_vertex_id
    end
  end
end


function find_vertex_around( npc, around_vertex, dir, rotate_min, rotate_max, offset_min, offset_max, sign, cover_cache )
  if not sign then sign = 1 end
  local ai_step     = 0.7 -- шаг AI сетки
  local math_pi_180 = 180 / math.pi

  local random_rotate    = math.random( rotate_min, rotate_max )
  local cur_dir          = vector_rotate_y( dir, random_rotate * sign )
  local random_offset    = math.random( offset_min, offset_max )
  local rotate_angle     = math.max(
    10, math.asin( ai_step / random_offset ) * math_pi_180
  )
  local rotate_angle_deg = rotate_angle * sign
  local cur_angle        = 0
  local vertex_id
  while not vertex_id do
    -- проверяем точку слева
    vertex_id = level.vertex_in_direction(
      around_vertex, cur_dir, random_offset
    )
    if
      vertex_id == around_vertex
      or ( not npc:accessible( vertex_id ) )
      or cover_cache[ vertex_id ] == false
      or check_vertex_locked( npc, vertex_id )
      or its_a_trap( npc, vertex_id )
    then
      cover_cache[ vertex_id ] = false
      vertex_id = nil
      -- поворачиваем направление поиска
      cur_angle = cur_angle + rotate_angle
      if rotate_min + cur_angle > rotate_max then
        break
      else
        cur_dir = vector_rotate_y( cur_dir, rotate_angle_deg )
      end
    else
      break
    end
  end
  return vertex_id
end


class "cover_cache_processor"
function cover_cache_processor:__init( npc, enemy )
  self.enemy = enemy
  self.npc   = npc
  self:clear()
end

function cover_cache_processor:clear()
  self.cache   = {}
  self.ordered = {}
end

function cover_cache_processor:get_cache()
  return self.cache
end

function cover_cache_processor:best_cover( cover )
  if cover then
    if not self.cache[ cover:level_vertex_id() ] then
      return self.ordered[ math.random( table.getn( self.ordered ) ) ]
    end
  elseif table.getn( self.ordered ) > 0 then
    return self.ordered[ math.random( table.getn( self.ordered ) ) ]
  end
  return cover
end

function cover_cache_processor:callback( cover, next_check )
  local cover_vertex = cover:level_vertex_id()
  local cached       = self.cache[ cover_vertex ]
  if cached ~= nil then return cached end
  self.cache[ cover_vertex ] = not (
    check_vertex_locked( self.npc, cover_vertex )
    or ( its_a_trap( self.npc, cover_vertex ) )
    or ( next_check and next_check( cover ) )
    or false
  )
  table.insert( self.ordered, cover )
  if table.getn( self.ordered ) == 50 then
    return true
  end
  return self.cache[ cover_vertex ]
end
