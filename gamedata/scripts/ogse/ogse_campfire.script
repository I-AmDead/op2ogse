-- -*- mode: lua; coding: windows-1251-dos -*-

local DIST_TO_ACTOR = 2
local DIST_TO_NPC   = 4
local SCAN_TIME     = 5000

local exclude_flames = {
  -- [ "zone_flame_small_kamin" ] = true, -- камин рядом со Свибловым
}

-- объекты с этими визуалами замечены в левитации и их нужно
-- возвращать на место
local known_visuals = {
  [ "objects\\fireplace\\fireplace_2" ] = true,
  [ "objects\\fireplace\\fireplace_3" ] = true,
  [ "objects\\koster_negorit"      ] = true,
  [ "objects\\koster_palki"        ] = true,
  [ "objects\\koster_palki_nastil" ] = true,
  [ "physics\\decor\\gas_burner"   ] = true,
}

-- радиус зоны вокруг костра, куда нельзя заходить мобам
local flame_radius = 1


function attach( sm )
  sm:subscribe({
    signal = "on_before_actor_conditions_update",
    fun    = this.actor_conditions_update
  })
  sm:subscribe({
    signal = "on_bind_physic_object",
    fun    = this.on_bind_physic_object
  })
  sm:subscribe({
    signal = "on_busy_hands_check", fun = this.on_busy_hands_check
  })
  sm:subscribe({ signal = "on_update", fun = this.on_actor_update })
end


local flames, flames_no_light, flames_no_palki = {}, {}, {}
local lights, lights_no_flame = {}, {}
local palki,  palki_no_flame  = {}, {}

local looking_into_flame = false
local nearest_campfire
local prev_actor_pos
local start_stand_time   = time_global()


function on_actor_update()
  ogse_signals.get_mgr():reschedule( 1000 )
  if not prev_actor_pos then prev_actor_pos = db.actor:position() end
  local dist = prev_actor_pos:distance_to( db.actor:position() )
  if dist > 0.1 then
    start_stand_time = time_global()
  end
  prev_actor_pos     = db.actor:position()
  looking_into_flame = false
  if db.actor.psy_health < 1 and stand_time() > 3000 then
    local pos = get_nearest_flame_pos( 2 )
    if pos then
      looking_into_flame = dsh.is_actor_looking_to_pos( pos, 0.5 )
    end
  end
end


function get_nearest_flame_pos( dist )
  if nearest_campfire and nearest_campfire:is_flame_enabled() then
    local pos = nearest_campfire.object:position()
    if pos:distance_to( db.actor:position() ) < dist then return pos end
  end
end


function find_nearest_flame_pos( dist )
  local npos = db.actor:position()
  for _, campfire in pairs( flames ) do
    local pos = campfire.object:position()
    local d   = pos:distance_to( npos )
    if d < dist then
      if campfire:is_flame_enabled() then return pos end
    end
  end
end


function get_nearest_campfire( pos, radius )
  local found = {}
  for _, campfire in pairs( flames ) do
    local pos2 = campfire.object:position()
    if pos2:distance_to( pos ) < radius then
      table.insert( found, campfire )
    end
  end
  table.sort(
    found,
    function( a, b )
      return pos:distance_to( a.object:position() ) < pos:distance_to( b.object:position() )
    end
  )
  if table.getn( found ) > 0 then
    return found[ 1 ]
  end
end


function actor_conditions_update( ext )
  if looking_into_flame then
    ext.psy_health_restore_speed = ext.psy_health_restore_speed + 0.006
  end
end


function stand_time()
  return time_global() - start_stand_time
end


function on_busy_hands_check( obj, binder, data )
  if not binder.ogse_campfire__koster_palki_binder then return end
  if data.usable and not amk_utils.inventory_search( "matches", 1 ) then
    data.tip_text = "Без спичек не получится"
    data.usable   = false
  end
end


function bind_unknown_light( obj )
  obj:bind_object( unknown_light_binder( obj ) )
end


class "unknown_light_binder" ( object_binder )
function unknown_light_binder:__init( obj ) super( obj )
end


function unknown_light_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  ASSERT(
    not db.net_spawning_obj,
    "found net_spawning_obj = %s",
    tostring( db.net_spawning_obj and db.net_spawning_obj:name() or nil )
  )
  db.net_spawning_obj = self.object
  lights[ self.object:level_vertex_id() ] = self.object:id()
  lights_no_flame[ self.object:id()     ] = true
  for id, campfire in pairs( flames_no_light ) do
    local dist = self.object:position()
      :distance_to( campfire.object:position() )
    if dist < 1 then
      flames_no_light[ id ] = nil
      lights[ campfire.object:level_vertex_id() ] = self.object:id()
      lights_no_flame[ self.object:id()         ] = nil
      campfire:on_light_spawn()
      break
    end
  end
  db.net_spawning_obj = false
  return true
end


function unknown_light_binder:net_destroy()
  lights[ self.object:level_vertex_id() ] = nil
  lights_no_flame[ self.object:id()     ] = nil
  object_binder.net_destroy( self )
end


function bind_flame( obj )
  if exclude_flames[ obj:name() ] then return end
  obj:bind_object( campfire_binder( obj ) )
end


-- типа конечный автомат:
--   next - переводит КА в следующее состояние
--     action - вызывается при переходе в данное состояние
states = {
  -- костер полностью погашен: аномалия отключена, лампа погашена,
  -- партиклы не играют
  turn_off = {
    need_actor = false,
    usable     = true,
    next = function( self, now )
      if self.has_users then
        return states.firing
      else
        return states.turn_off
      end
    end,
    action = function( self )
      self:switch_flame( false )
      if self.particle then self.particle:stop() end
      self:switch_light( false )
      self:enable_palki_on_use()
    end,
  },

  -- костер горит на полную: аномалия включена, лампочка горит, партиклов нет
  firing = {
    need_actor = true,
    usable     = false,
    next = function( self, now )
      if self.has_actor or self.has_users then
        self.time = now
        return states.firing
      elseif self.time + 1800000 > now then
        return states.firing
      else
        return states[ self.state_down ]
      end
    end,
    action = function( self )
      self:switch_flame( true  )
      self:switch_light( false )
      if self.particle then self.particle:stop() end
      self:disable_palki_on_use()
    end,
  },

  -- костер начинает гаснуть: аномалия еще включена, лампочка горит,
  -- включается партикл затухающего огня
  down = {
    need_actor = true,
    usable     = false,
    next = function( self, now )
      if self.has_actor or self.has_users then
        return states.firing
      elseif self.time + 5000 < now then
        return states.flame_off
      else
        return states.down
      end
    end,
    action = function( self )
      self:switch_flame( true  )
      self:switch_light( false )
      if not self.particle then
        self.particle = particles_object( "dyn_kfire\\dyingfire" )
      end
      self:play_particle_near_light()
    end,
  },

  -- следующий этап угасания: отключается аномалия, но лампочка еще горит,
  -- партикл играется
  flame_off = {
    need_actor = true,
    usable     = false,
    next = function( self, now )
      if self.has_actor or self.has_users then
        return states.firing
      elseif self.time + 32000 < now then
        return states.turn_off
      else
        return states.flame_off
      end
    end,
    action = function( self )
      self:switch_flame( false )
      self:switch_light( true  )
      if not self.particle then
        self.particle = particles_object( "dyn_kfire\\dyingfire" )
        self:play_particle_near_light()
      end
    end,
  },
}


class "campfire_binder" ( object_binder )
function campfire_binder:__init( obj ) super( obj )
  self.flame_enabled = true
  self.has_light     = get_bool(
    obj:section(), "ogse_campfire.has_light", true
  )
  self.initialized   = false
  self.has_actor     = false
  self.has_user      = false
  self.loaded        = false
  self.state         = states.turn_off
  self.state_down    = get_string(
    obj:section(), "ogse_campfire.state_down", "down"
  )
  self.switch_light_on_update = false
  self.usable        = false
end


function campfire_binder:reinit()
  db.storage[ self.object:id() ] = {}
  self.st = db.storage[ self.object:id() ]
end


function campfire_binder:check_npc( npc )
  if not npc then return false end
  if not npc:alive() then return false end
  local dists = { [ false ] = DIST_TO_NPC, [ true ] = DIST_TO_ACTOR }
  local dist  = self.object:position():distance_to( npc:position() )
  if dist > dists[ npc:id() == db.actor:id() ] then
    return false
  end
  if npc:id() == db.actor:id() then
    if stand_time() < 3000 then return false end
  else
    local camp_anims = {
      [ "sit"      ] = true,
      [ "sit_ass"  ] = true,
      [ "sit_knee" ] = true,
    }
    if db.storage[ npc:id() ].state_mgr then
      local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
      if not camp_anims[ anim ] then return false end
    end
  end
  return true
end


function campfire_binder:find_light()
  local id = lights[ self.object:level_vertex_id() ]
  if id then
    return level.object_by_id( id )
  end
end


function campfire_binder:find_palki()
  return palki[ self.object:level_vertex_id() ]
end


function campfire_binder:update( delta )
  if self.shutdown then
    ASSERT(
      ( not self.shutdowned ),
      "[%s]: %s: oops, already shutdowned", script_name(), self.object:name()
    )
    self.object:disable_anomaly()
    self.shutdowned = true
    return
  end
  if ( not self.initialized ) and db.actor then
    self.initialized = true
    xr_logic.initialize_obj(
      self.object, self.st, self.loaded, db.actor, modules.stype_item
    )
  end
  if self.switch_light_on_update then
    self:switch_light( false )
    self.switch_light_on_update = false
  end
  local time = time_global()
  if not self.scan_time then
    self.scan_time = time
    self.state.action( self )
    self.time      = time
  elseif self.scan_time < time then
    if
      nearest_campfire and nearest_campfire.object:id() == self.object:id()
    then
      if self.state.need_actor then
        self.has_actor = self:check_npc( db.actor )
      else
        self.has_actor = false
      end
    else
      self.has_actor = false
    end
    local new_state = self.state.next( self, time )
    ASSERT( new_state ~= nil, "new_state ~= nil" )
    self:set_state( new_state, time )
    self.scan_time = time + SCAN_TIME
  end
  if ( not self.check_actor ) or self.check_actor < time_global() then
    self:get_actor_check_delay()
    if nearest_campfire then
      local obj = nearest_campfire.object
      if obj:id() ~= self.object:id() then
        if self.actor_dist < obj:position():distance_to( db.actor:position() ) then
          nearest_campfire = self
        end
      end
    else
      nearest_campfire = self
    end
    if not self:find_palki() then
      self:show_quick_info()
    elseif self.has_quick_info then
      self:lost_quick_info()
      dsh_hud_quickinfo.hide_quick_info()
    end
    self.check_actor = time_global() + self.actor_delay
  end
end


function campfire_binder:get_actor_check_delay()
  local dist = self.object:position():distance_to( db.actor:position() )
  self.actor_dist  = dist
  self.actor_delay = ( dist < 10 and 500 )
    or ( dist <  50 and math.random( 1000, 1500 ) )
    or ( dist < 100 and math.random( 2000, 3000 ) )
    or math.random( 5000, 6000 )
  return self.actor_delay, self.actor_dist
end


local found_flame_here = {}

function campfire_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  ASSERT(
    not db.net_spawning_obj,
    "found net_spawning_obj = %s",
    tostring( db.net_spawning_obj and db.net_spawning_obj:name() or nil )
  )
  db.net_spawning_obj = self.object
  local dist, found
  for id, campfire in pairs( flames ) do
    dist = self.object:position()
      :distance_to( campfire.object:position() )
    if dist < 1 then
      found = campfire
      found_flame_here[ self.object:level_vertex_id() ] = campfire
      break
    end
  end
  if found then
    log2(
      "[%s]: %s: found %s on my vertex %s (%s), shutdown myself",
      script_name(), self.object:name(), found.object:name(),
      self.object:level_vertex_id(), dist
    )
    self.shutdown = true
  else
    found_flame_here[ self.object:level_vertex_id() ] = self
    self:register_campfire()
  end
  db.net_spawning_obj = false
  return true
end


function campfire_binder:register_campfire()
  flames[ self.object:id() ] = self
  if self.has_light then
    -- ищем лампочку
    local light = self:find_light()
    if light then
      lights_no_flame[ light:id() ] = nil
    else
      for id, _ in pairs( lights_no_flame ) do
        local obj = level.object_by_id( id )
        if obj then
          local dist = self.object:position():distance_to( obj:position() )
          if dist < 1 then
            light = obj
            lights[ self.object:level_vertex_id() ] = id
            lights_no_flame[ id ] = nil
            break
          end
        end
      end
      if not light then
        flames_no_light[ self.object:id() ] = self
      end
    end
    if light then self:switch_light( false ) end
  end
  -- ищем кострище
  local found_palki = self:find_palki()
  if found_palki then
    palki_no_flame[ found_palki.object:id() ] = nil
  else
    for id, _ in pairs( palki_no_flame ) do
      local obj = level.object_by_id( id )
      if obj then
        local dist = self.object:position():distance_to( obj:position() )
        if dist < 1 then
          found_palki = obj:binded_object()
          palki[ self.object:level_vertex_id() ] = found_palki
          palki_no_flame[ id ] = nil
          break
        end
      end
    end
    if not found_palki then
      flames_no_palki[ self.object:id() ] = self
    end
  end
  -- self:create_restrictor()
end


function campfire_binder:create_restrictor()
  local vertexes = dsh.find_all_vertexes_in_radius(
    self.object:position(), flame_radius
  )
  for _, vertex_id in ipairs( vertexes ) do
    level.disable_vertex( vertex_id )
  end
end


function campfire_binder:net_destroy()
  local st = db.storage[ self.object:id() ]
  if st.active_scheme then
    xr_logic.issue_event( self.object, st[ st.active_scheme ], "net_destroy" )
  end
  self:stop_idle()
  flames[ self.object:id()          ] = nil
  flames_no_light[ self.object:id() ] = nil
  object_binder.net_destroy( self )
end


function campfire_binder:net_save_relevant()
  return true
end


function campfire_binder:save( packet )
  object_binder.save( self, packet )
  xr_logic.save_obj( self.object, packet, not self.initialized )
  local state_name = nil
  for k,v in pairs( states ) do
    if v == self.state then state_name = k end
  end
  ASSERT( state_name ~= nil, "state_name ~= nil" )
  packet:w_stringZ( state_name )
end


function campfire_binder:load( reader )
  self.loaded = true
  object_binder.load( self, reader )
  xr_logic.load_obj( self.object, reader )
  if reader:r_eof() then return end
  local state = reader:r_stringZ()
  self.state  = states[ state ]
  if not self.state then
    self.state = states.turn_off
  end
  ASSERT( self.state ~= nil, "self.state ~= nil" )
end


function campfire_binder:switch_light( ena )
  if not self.has_light then return end
  local light = self:find_light()
  if not light then return end
  local lamp = light:get_hanging_lamp()
  if not lamp then return end
  if ena then
    lamp:turn_on()
  else
    lamp:turn_off()
  end
end


function campfire_binder:switch_flame( ena )
  local flame = self.object
  if ena then
    self:stop_idle()
    flame:enable_anomaly()
    self.flame_enabled = true
  else
    flame:disable_anomaly()
    self.flame_enabled = false
    self:start_idle()
  end
end


function campfire_binder:start_idle()
  self.idle_t = dsh.exec_periodic(
    nil,
    function( timer )
      if ogse_sleep_mgr.is_sleep_active() then return end
      self:update()
      timer:reschedule( self.actor_delay )
    end
  )
  self.idle_t:set_script_name( "campfire_binder.start_idle" )
end


function campfire_binder:stop_idle()
  if self.idle_t then
    self.idle_t:stop()
    self.idle_t = nil
  end
end


function campfire_binder:play_particle_near_light( particle )
  self.particle:play_at_pos( self.object:position() )
end


function campfire_binder:on_light_spawn()
  self.switch_light_on_update = true
end


function campfire_binder:on_palki_spawn()
  if self.state.usable then
    self:enable_palki_on_use( self )
  end
end


function campfire_binder:enable_palki_on_use()
  self.usable = true
  local found_palki = self:find_palki()
  if found_palki then
    found_palki:enable_on_use( self )
  end
end


function campfire_binder:disable_palki_on_use()
  self.usable = false
  local found_palki = self:find_palki()
  if found_palki then
    found_palki:disable_on_use()
  end
end


local quick_info_campfire
function campfire_binder:show_quick_info()
  if
    self.usable
    and self.actor_dist < get_actor_obj().inventory.take_dist
    and not ( level.get_target_obj() or level.main_input_receiver() )
  then
    local looking = dsh.is_actor_looking_to_pos( self.object:position(), 0.5 )
    if looking then
      if not self.has_quick_info then
        if quick_info_campfire then
          quick_info_campfire:lost_quick_info()
        end
        quick_info_campfire = self
        self:subscribe_use_events()
        self.has_quick_info = true
      end
      self.has_matches = amk_utils.inventory_search( "matches", 1 )
      dsh_hud_quickinfo.show_quick_info( self:get_quick_info_text() )
    elseif self.has_quick_info then
      self:lost_quick_info()
      dsh_hud_quickinfo.hide_quick_info()
    end
  elseif self.has_quick_info then
    self:lost_quick_info()
    dsh_hud_quickinfo.hide_quick_info()
  end
end


function campfire_binder:lost_quick_info()
  self:unsubscribe_use_events()
  self.has_matches    = false
  self.has_quick_info = false
  quick_info_campfire = nil
end


function campfire_binder:get_quick_info_text()
  return dsh_busy_hands.actor_has_free_hands()
    and ( self.has_matches and "Разжечь" or "Без спичек не получится" )
    or  "dsh_busy_hands"
end


function campfire_binder:set_state( state, time )
  if self.state ~= state then
    state.action( self )
    self.state = state
    self.time  = time or time_global()
  end
end


function campfire_binder:subscribe_use_events()
  self.use_events_subscribed = {
    signal = "on_key_down", fun = self.on_key_down, self = self
  }
  ogse_signals.get_mgr():subscribe( self.use_events_subscribed )
end


function campfire_binder:unsubscribe_use_events()
  ogse_signals.get_mgr():unsubscribe( self.use_events_subscribed )
  self.use_events_subscribed = nil
end


function campfire_binder:on_key_down( key, bind )
  if
    level.main_input_receiver()
    or bind ~= key_bindings.kUSE
    or not ( dsh_busy_hands.actor_has_free_hands() and self.has_matches )
    or db.eat
  then
    return
  end
  self:fire_campfire_fx()
end


function campfire_binder:fire_campfire_fx()
  local rnd = 0.8
  if level.rain_factor() > 0 and not isIndoor( level.name() ) then
    local pos = self.object:position()
    pos.y = pos.y + 1
    local rq = level.ray_query(
      pos, vector():set( 0, 1, 0 ), 100, rq_target.rqtBoth, db.actor
    )
    if not rq.result then
      rnd = 0.2 + ( rnd - 0.2 ) * ( 1 - level.rain_factor() )
    end
  end
  self:disable_palki_on_use()
  self:show_quick_info()
  if math.random() < 0.6 then
    local has_matches, t = amk_utils.inventory_search_check({ [ "matches" ] = 1 })
    ASSERT( has_matches, "[%s]: matches not found", script_name() )
    ogse.remove_item_from_inventory( t[ 1 ] )
  end
  dsh_hud_fx.run_fx(
    self.object:section(), "campfire", nil,
    {
      [ "campfire" ] = self,
      [ "lucky"    ] = ( math.random() < rnd ),
    }
  )
end


function campfire_binder:fire_campfire()
  self:set_state( states.firing )
end


function campfire_binder:spawn_matches_flame( delay )
  local pos = self.object:position()
  pos.y = pos.y + 1
  local sobj = amk_anoms.spawn_anomaly(
    "zone_flame_matches",
    pos, self.object:level_vertex_id(), self.object:game_vertex_id(),
    { shtype = 0, radius = 0.1, center = { 0, 0, 0 } }
  )
  sobj     = alife():object( sobj.id )
  local sr = sobj:get_space_restrictor()
  sr.restrictor_type = global_flags.eRestrictorTypeNone
  dsh.timeout( delay, function() alife():release( sobj ) end )
end


function campfire_binder:is_flame_enabled()
  if
    self.flame_enabled
    or ( self.particle and self.particle:playing() )
  then
    return true
  end
  return false
end


function on_bind_physic_object( obj )
  if known_visuals[ obj:get_visual_name() ] then
    obj:bind_object( koster_palki_binder( obj ) )
    return true
  end
end


class "koster_palki_binder" ( object_binder )
function koster_palki_binder:__init( obj ) super( obj )
  self.ogse_campfire__koster_palki_binder = true
  self.on_use_configured = false
  self.updated = false
end


function koster_palki_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  ASSERT(
    not db.net_spawning_obj,
    "found net_spawning_obj = %s",
    tostring( db.net_spawning_obj and db.net_spawning_obj:name() or nil )
  )
  db.net_spawning_obj = self.object
  palki[ self.object:level_vertex_id() ] = self
  palki_no_flame[ self.object:id()     ] = true
  for id, campfire in pairs( flames_no_palki ) do
    local dist = self.object:position()
      :distance_to( campfire.object:position() )
    if dist < 1 then
      flames_no_palki[ id ] = nil
      palki[ campfire.object:level_vertex_id() ] = self
      palki_no_flame[ self.object:id()         ] = nil
      campfire:on_palki_spawn()
      break
    end
  end
  db.net_spawning_obj = false
  return true
end


function koster_palki_binder:net_destroy()
  palki[ self.object:level_vertex_id() ] = nil
  palki_no_flame[ self.object:id()     ] = nil
  self:disable_on_use()
  object_binder.net_destroy( self )
end


function koster_palki_binder:update( delta )
  if self.updated then return end
  local sobj = alife():object( self.object:id() )
  if sobj then
    local dist = sobj.position:distance_to( self.object:position() )
    if dist > 0.1 then
      log2(
        "[%s]: found wrong position of %s: sobj y = %s, self.object y = %s, dist = %s",
        script_name(), self.object:name(),
        sobj.position.y, self.object:position().y, dist
      )
      local pk = get_netpk( sobj, 1 )
      ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
      local orig = pk:get()
      local new  = alife():create(
        "physic_object",
        sobj.position, sobj.m_level_vertex_id, sobj.m_game_vertex_id
      )
      pk = get_netpk( new, 1 )
      ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
      local data = pk:get()
      for _, k in ipairs({
        "fixed_bones", "mass", "physic_type", "visual_name"
      }) do
        data[ k ] = orig[ k ]
      end
      data.custom_data:setTable( orig.custom_data:getTable() )
      pk:set( data )
      log2(
        "[%s]: new %s spawned: %s",
        script_name(), data.visual_name, new:name()
      )
      dsh.exec_on_update(
        function( id )
          local sobj = alife():object( id )
          if sobj then alife():release( sobj ) end
        end,
        sobj.id
      )
    end
  end
  self.updated = true
end


function koster_palki_binder:enable_on_use( campfire )
  if self.on_use_configured then return end
  self.campfire = campfire
  self.object:set_callback( callback.use_object, self.use_callback, self )
  self[ "dsh_busy_hands.cfg" ] = {
    [ "need_hands"   ] = "dsh_busy_hands",
    [ "tip_text_def" ] = "Разжечь",
  }
  ogse_signals.get_mgr():call( "on_ph_spawn", self.object, self )
  self.on_use_configured = true
end


function koster_palki_binder:disable_on_use()
  if not self.on_use_configured then return end
  self.object:set_callback( callback.use_object, nil )
  ogse_signals.get_mgr():call( "on_ph_net_destroy", self.object, self )
  self.object:set_tip_text( "" )
  self.on_use_configured = false
end


function koster_palki_binder:use_callback( obj, who )
  if self.dsh_busy_hands_nonusable then return end
  self.campfire:fire_campfire_fx()
end
