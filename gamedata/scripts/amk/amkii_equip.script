-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- Developed by AMK-Team
-- File:  amkII_equip.script
-- Copyright:  ©  AMK-Team 2009
-- Author: Refresh

-- Opimized for OGSE 0.6.9.3 by KamikaZze

-- Since: 07.02.2009 20:15
--         -- Заготовка.
-- Since: 08.02.2009 1:08
--         -- Написан класс.
--         -- Неписи переодеваются.
-- Since: 08.02.2009 16:42
--         -- Модуль переодевания добавлен в схему gatherer и убран из
--         -- апдейта. (оптимизация)
-- Since: 09.02.2009 1:28
--         -- Теперь нпс, надеваю экзу или научный костюм, выбирают
--         -- подходящий под клан цвет.  Убрана итерация по инвентарю,
--         -- айтим теперь передает тоже gatherer. (оптимизация)

function attach( sm )
  sm:subscribe({ signal = "on_npc_death",       fun = this.on_death     })
  sm:subscribe({ signal = "on_npc_net_destroy", fun = this.on_death     })
  sm:subscribe({ signal = "on_npc_spawn",       fun = this.on_npc_spawn })
end


function on_npc_spawn( obj, binder )
  if not can_refit( obj ) then return end
  local subscribed = {
    {
      [ "signal" ] = "on_npc_update." .. obj:id(),
      [ "fun"    ] = this.on_update,
    },
  }
  binder[ "amkii_equip.subscribed" ] = subscribed
  for _, s in ipairs( subscribed ) do
    ogse_signals.get_mgr():subscribe( s )
  end
end


function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ "amkii_equip.subscribed" ]
  if subscribed then
    for _, s in ipairs( subscribed ) do
      ogse_signals.get_mgr():unsubscribe( s )
    end
    binder[ "amkii_equip.subscribed" ] = nil
  end
end


function on_update( obj )
  ogse_signals.get_mgr():reschedule( math.random( 1000, 5000 ) )
  CAmkDisguise( obj ):PeriodicalUpdate()
end


local needs_refit      = {}
local excluded_npcs    = amkii_equip_data.excluded_npcs
local armor_levels     = amkii_equip_data.armor_levels
local suits_to_visuals = amkii_equip_data.suits_to_visuals
local vis_to_sect      = amkii_equip_data.vis_to_sect
local vis_find_to_sect = amkii_equip_data.vis_find_to_sect


-- amkDel(oItem)
-- Удаляем обьект из симуляции.
-- @param  object  oItem           Обьект.

function amkDel( oItem )
  local item = alife():object( oItem:id() )
  if item then
    alife():release( item, true )
  end
end


function can_refit( oNpc )
  if not ( oNpc and oNpc:alive() ) then return false end
  if get_bool( oNpc:section(), "amkii_equip.can_refit" ) then
    return true
  end
  if
    excluded_npcs[ oNpc:name() ]
    or excluded_npcs[ oNpc:section() ]
    or excluded_npcs[ oNpc:profile_name() ]
    or ogse.is_quest_npc( oNpc )
  then
    return false
  end
  return true
end


local info_by_visual = {}
function get_npc_current_visual( npc, vis )
  if not vis then
    vis = table.remove(
      amk.str_explode( "\\", npc:get_visual_name() )
    )
  end
  if not info_by_visual[ vis ] then
    local sect = vis_to_sect[ vis ]
    if not sect then
      for _,v in ipairs( vis_find_to_sect ) do
        if string.find( vis, v[ 1 ] ) then
          sect = v[ 2 ]
          break
        end
      end
    end
    info_by_visual[ vis ] = { 10, sect }
    if sect then
      local vis_suit = get_string( sect, "visual" )
      if vis_suit then
        vis_suit = xrs_utils.str_explode( "\\", vis_suit )
        if vis_suit[ 2 ] then
          vis_suit = xrs_utils.str_explode( ".", vis_suit[ 2 ] )
        end
        vis_suit = vis_suit[ 1 ]
        if armor_levels[ vis_suit ] then
          info_by_visual[ vis ][ 1 ] = armor_levels[ vis_suit ]
        end
      end
    else
      log2(
        "[%s]: section for %s not found: %s",
        script_name(), npc:name(), vis
      )
    end
  end
  return unpack( info_by_visual[ vis ] )
end


class "CAmkDisguise"
function CAmkDisguise:__init( npc )
  self.npc = npc
end


function CAmkDisguise:get_npc_current_visual()
  local npc = self.npc
  if not self.new_visual_name then
    local binder = npc:binded_object()
    self.new_visual_name = binder[ "amkii_equip.new_visual_name" ]
  end
  return get_npc_current_visual( npc, self.new_visual_name )
end


function CAmkDisguise:set_new_visual_name( vis )
  local npc = self.npc
  self.new_visual_name = "actors\\" .. vis
  local binder = npc:binded_object()
  binder[ "amkii_equip.new_visual_name" ] = self.new_visual_name
end


-- Update(oBinder)
-- Апдейтим сталкера на предмет крутого костюма в инвентаре.
-- И если костюм есть и его визуал круче чем текущий, то переодеваем нпс.
-- @param  object  oBinder         Биндер сталкера.

function CAmkDisguise:Update( oItem )
  local oNpc = self.npc
  if not can_refit( oNpc ) then return end
  local com = oNpc:character_community()
  if not suits_to_visuals[ com ] then return end
  local vis = table.remove(
    amk.str_explode( "\\", oItem:get_visual_name() )
  )
  local avail = suits_to_visuals[ com ][ vis ]
  if not avail then return end
  local cur_armor_l, cur_armor_sect = self:get_npc_current_visual()
  if cur_armor_sect and cur_armor_l < armor_levels[ vis ] then
    local sobj = alife():object( oNpc:id() )
    local pk   = get_netpk( sobj, 1 )
    ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
    self:set_new_visual_name( avail[ math.random( table.getn( avail ) ) ] )
    local data = pk:get()
    local cost = get_float( cur_armor_sect, "cost" )
    data.money = data.money + math.floor( cost / 20 )
    data.visual_name = self.new_visual_name
    pk:set( data )
    local rank = 270 * armor_levels[ vis ] + math.random( 50 )
    if oNpc:character_rank() < rank and sobj:rank() < rank then
      oNpc:set_character_rank( rank )
    end
    needs_refit[ oNpc:id() ] = true
    amkDel( oItem )
  end
end


-- переодевание
function refit_npc( npc, npc_id )
  local s_npc = alife():object( npc_id )
  s_npc.force_offline = true
  go_offline_watch_timer( npc_id ):start()
end


-- служебный таймер, ждущий ухода в оффлайн
class "go_offline_watch_timer" ( ogse_qt.quick_timer )
function go_offline_watch_timer:__init( npc_id ) super()
  self.npc_id = npc_id          -- запоминаем в таймере id непися
end

function go_offline_watch_timer:condition()
  -- ждём исчезновения клиентского объекта
  return ( not level.object_by_id( self.npc_id ) )
end

function go_offline_watch_timer:action()
  local s_npc = alife():object( self.npc_id )
  if s_npc then
    s_npc.force_offline = nil   -- отправляем обратно в онлайн
  end
end


-- периодическая перепроверка
function CAmkDisguise:PeriodicalUpdate()
  local oNpc = self.npc
  if not can_refit( oNpc ) then return end
  if needs_refit[ oNpc:id() ] then
    if not (
      xr_wounded.is_wounded( oNpc )
      or xrs_battle_ai.actor_see( oNpc ) or oNpc:is_talking()
      or xrs_battle_ai.get_target( oNpc ) or oNpc:best_enemy()
    ) then
      oNpc:clear_animations()
      needs_refit[ oNpc:id() ] = nil
      refit_npc( oNpc, oNpc:id() )
      return
    end
  end
  oNpc:iterate_inventory(
    function( npc, item )
      if item:is_outfit() then
        if alife():object( item:id() ) then
          self:Update( item )
        end
      end
    end,
    oNpc
  )
  if not needs_refit[ oNpc:id() ] then
    local binder     = oNpc:binded_object()
    local subscribed = binder[ "amkii_equip.subscribed" ]
    local sm         = ogse_signals.get_mgr()
    if subscribed then
      for _, s in ipairs( subscribed ) do
        sm:unsubscribe( s )
      end
    end
    subscribed = {
      {
        signal = "on_npc_item_take." .. oNpc:id(),
        fun    = this.on_npc_item_take,
      },
    }
    for _, s in ipairs( subscribed ) do
      sm:subscribe( s )
    end
    binder[ "amkii_equip.subscribed" ] = subscribed
  end
end


function on_npc_item_take( npc, obj, sobj )
  if not obj:is_outfit() then return end
  local binder     = npc:binded_object()
  local subscribed = binder[ "amkii_equip.subscribed" ]
  local sm         = ogse_signals.get_mgr()
  if subscribed then
    for _, s in ipairs( subscribed ) do
      sm:unsubscribe( s )
    end
  end
  subscribed = {
    {
      [ "signal" ] = "on_npc_update." .. npc:id(),
      [ "fun"    ] = this.on_update,
    },
  }
  binder[ "amkii_equip.subscribed" ] = subscribed
  for _, s in ipairs( subscribed ) do
    sm:subscribe( s )
  end
end


function CAmkDisguise:set_community_visual()
  local npc = self.npc
  if not can_refit( npc ) then return end
  local cur_armor_l, cur_armor_sect = self:get_npc_current_visual()
  if not cur_armor_sect then return end
  local com = npc:character_community()
  if not suits_to_visuals[ com ] then return end
  local vis = table.remove(
    amk.str_explode( "\\", get_string( cur_armor_sect, "visual" ) )
  )
  local avail = suits_to_visuals[ com ][ vis ]
  if not avail then return end
  self:set_new_visual_name( avail[ math.random( table.getn( avail ) ) ] )
  log2(
    "[%s]: change visual of %s: %s -> %s",
    script_name(), npc:name(), npc:get_visual_name(), self.new_visual_name
  )
  local sobj = alife():object( npc:id() )
  local pk   = get_netpk( sobj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
  local data = pk:get()
  data.visual_name = self.new_visual_name
  pk:set( data )
end


function set_community_visual( npc )
  CAmkDisguise( npc ):set_community_visual()
end
