-- -*- mode: lua; coding: windows-1251-dos -*-

-- Этот скрипт эмулирует поглощение энергии хита артефактами,
-- размещенными на поясе.  Каждый артефакт, находящийся под контролем
-- скрипта, способен поглотить определенное кол-во энергии, после
-- чего, он преобразуется в булыжник.

-- какие типы хита будут обрабатываться и их классы
local our_hits = {
  [ hit.explosion     ] = "explosion_immunity",
  [ hit.fire_wound    ] = "fire_wound_immunity",
  [ hit.strike        ] = "strike_immunity",
  [ hit.wound         ] = "wound_immunity",
  [ hit.burn          ] = "burn_immunity",
  [ hit.chemical_burn ] = "chemical_burn_immunity",
  [ hit.shock         ] = "shock_immunity",
  [ hit.radiation     ] = "radiation_immunity",
  [ hit.telepatic     ] = "telepatic_immunity",
  [ "bleeding"        ] = "bleeding_restore_speed",
  [ "health"          ] = "health_restore_speed",
  [ "power"           ] = "power_restore_speed",
  [ "radiation"       ] = "radiation_restore_speed",
  [ "satiety"         ] = "satiety_restore_speed",
  [ "weight2"         ] = "additional_inventory_weight2",
}

-- максимальное время жизни артефакта на поясе (сек.)
local max_idle_life_time = 7 * 24 * 3600


function attach( sm )
  sm:subscribe({ signal = "on_actor_before_hit", fun = this.before_hit })
  sm:subscribe({ signal = "on_first_update",     fun = this.on_first_update })
  sm:subscribe({ signal = "on_sleep_finished",   fun = this.on_sleep_finished })
  sm:subscribe({ signal = "on_use",              fun = this.on_use  })
end


function on_first_update()
  for k, v in pairs( our_hits ) do
    our_hits[ k ] = this[ v ]()
  end
  local sm = ogse_signals.get_mgr()
  sm:subscribe({
    signal = "on_update2", fun = this.process_hits,
    [ "script_name" ] = "dsh_art_degrad.process_hits"
  })
  sm:subscribe({
    signal = "on_update2", fun = this.process_arts,
    [ "script_name" ] = "dsh_art_degrad.process_arts"
  })
end


local got_hits = {}
local has_hit  = false
local new_hit  = {
  [ "bleeding"  ] = false,
  [ "health"    ] = false,
  [ "radiation" ] = false,
}
local psy_block_start, psy_block_t

function before_hit( hit_data )
  local hit_type = hit_data.hit_type
  local our_hit  = our_hits[ hit_type ]
  local power    = hit_data.full_power
  if our_hit and power > 0 then
    local power_k = our_hit.power_k or 1
    got_hits[ hit_type ] = ( got_hits[ hit_type ] or 0 ) + power * power_k
    has_hit = true
    if our_hit.new_hit then
      for _, k in ipairs( our_hit.new_hit ) do
        new_hit[ k ] = true
      end
    end
    if
      hit_data.hit_type == hit.telepatic
      and psy_block_t and time_global() < psy_block_t
    then
      local full = psy_block_t - psy_block_start
      local used = time_global() - psy_block_start
      hit_data.power = hit_data.power * ( used / full )
    end
  end
end


local absorbations   = {}
local need_addl_keys = {
  [ "additional_inventory_weight2" ] =  1,
  [ "bleeding_restore_speed"       ] =  1,
  [ "health_restore_speed"         ] =  1,
  [ "power_restore_speed"          ] =  1,
  [ "radiation_restore_speed"      ] = -1,
  [ "satiety_restore_speed"        ] =  1,
}

function get_absorbations( af )
  local af_sect = af:section()
  if not absorbations[ af_sect ] then
    local absorb_sect = get_string( af_sect, "hit_absorbation_sect" )
    if absorb_sect then
      if not absorbations[ af_sect ] then
        absorbations[ af_sect ] = {}
        for _, k in ipairs( get_section_keys( absorb_sect ) ) do
          local absorb_val = 1 - get_float( absorb_sect, k, 1 )
          if absorb_val > 0 then
            absorbations[ af_sect ][ k ] = absorb_val
          end
        end
      end
    end
    for k, v in pairs( need_addl_keys ) do
      local val = get_float( af_sect, k, 0 )
      if     v > 0 and val > 0 then
        absorbations[ af_sect ][ k ] = val
      elseif v < 0 and val < 0 then
        absorbations[ af_sect ][ k ] = math.abs( val )
      end
    end
  end
  return absorbations[ af_sect ]
end


local run_coef    = get_float( "actor", "run_coef"    )
local sprint_coef = get_float( "actor", "sprint_koef" )
local sprint_degrad_k = sprint_coef / run_coef

function process_hits()
  local act = db.actor
  if
    ogse_sleep_mgr.is_sleep_active()
    or not act.conditions.has_valid_time
  then
    return
  end
  local dt = act.conditions:fdelta_time()
  if dt <= 0 then return end

  got_hits.satiety = ( got_hits.satiety or 0 ) + dt

  if act:get_bleeding() > 0 or new_hit.bleeding then
    got_hits.bleeding = ( got_hits.bleeding or 0 ) + dt
    new_hit.bleeding  = false
    has_hit = true
  end

  if act.health < 1 or new_hit.health then
    got_hits.health = ( got_hits.health or 0 ) + dt
    new_hit.health  = false
    has_hit = true
  end

  local aobj = get_actor_obj()
  local sprint_k = 1
  if aobj:is_actor_sprinting() then
    sprint_k = sprint_degrad_k
  end

  if act.power < 1 or aobj:is_actor_moving() then
    got_hits.power = ( got_hits.power or 0 ) + dt * sprint_k
    has_hit = true
  end

  if aobj:is_actor_moving() then
    got_hits.weight2 = ( got_hits.weight2 or 0 ) + dt * sprint_k
    has_hit = true
  end

  if
    act.radiation > 0
    or new_hit.radiation
    or arc_radiation.get_inv_arts_radiation() > 0
  then
    got_hits.radiation = ( got_hits.radiation or 0 ) + dt
    new_hit.radiation  = false
    has_hit = true
  end
end


function process_arts()
  ogse_signals.get_mgr():reschedule( 1000 )
  if not ( got_hits.satiety and got_hits.satiety > 0 ) then return end
--[=[
  if
    not (
      has_hit
      or inventory.on_belt_restore_speed_pos( "satiety_restore_speed" )
    )
  then
    return
  end
--]=]
  local empty = {}
  for i = 0, db.actor:belt_count() - 1 do
    local af = db.actor:item_on_belt( i )
    if af:is_artefact() then
      local af_sect = af:section()
      local absorbs = get_absorbations( af )
      local af_cond = af:condition()
      if absorbs and af_cond > 0 then
        local cond_diff = 0
        for hit_type, hit_power in pairs( got_hits ) do
          local our_hit = our_hits[ hit_type ]
          if absorbs[ our_hit.sect ] then
            local absorb_val = our_hit:absorbation( absorbs ) * hit_power
            cond_diff = cond_diff + ( absorb_val / our_hit.max )
          end
        end
        if cond_diff == 0 then
          for k, v in pairs( absorbs ) do
            cond_diff = cond_diff + got_hits.satiety / max_idle_life_time
            break
          end
        end
        if cond_diff > 0 then
          if af_cond > cond_diff then
            dsh.set_condition( af, af_cond - cond_diff )
          else
            table.insert( empty, af )
          end
        end
      end
    end
  end
  for _, af in ipairs( empty ) do
    degrade_artefact( af )
  end
  for hit_type, hit_power in pairs( got_hits ) do
    got_hits[ hit_type ] = 0
  end
  has_hit = false
end


function on_use( obj, sobj )
  if obj:section() == "vodka" then
    if psy_block_t and time_global() < psy_block_t then
      psy_block_t = psy_block_t   + 300000
    else
      psy_block_t = time_global() + 300000
    end
    psy_block_start = time_global()
    dsh_sleep.change_gg_need_sleep( 30 )
  end
end


function on_sleep_finished( sleep_seconds )
  psy_block_t = nil
end


function degrade_artefact( af )
  zero_all_af_effects( af )
  dsh.set_condition( af, 0 )
  inventory.rescan_belt()
end


class "hit_immunity"
function hit_immunity:__init() end
function hit_immunity:absorbation()
  return inventory.on_belt_hit_immunity( self.sect )
end

class "restore_speed_neg"
function restore_speed_neg:__init() end
function restore_speed_neg:absorbation()
  return inventory.on_belt_restore_speed_neg( self.sect )
end

class "restore_speed_pos"
function restore_speed_pos:__init() end
function restore_speed_pos:absorbation()
  return inventory.on_belt_restore_speed_pos( self.sect )
end

class "self_absorbation"
function self_absorbation:__init() end
function self_absorbation:absorbation( t )
  return t[ self.sect ]
end


class "explosion_immunity" ( hit_immunity )
function explosion_immunity:__init() super()
  self.max     = 5              -- порог поглощения
  self.new_hit = { "bleeding", "health" }
  self.sect    = "explosion_immunity"
end


class "fire_wound_immunity" ( hit_immunity )
function fire_wound_immunity:__init() super()
  self.max     = 10
  self.new_hit = { "bleeding", "health" }
  self.sect    = "fire_wound_immunity"
end


class "strike_immunity" ( hit_immunity )
function strike_immunity:__init() super()
  self.max     = 2.5
  self.new_hit = { "bleeding", "health" }
  self.sect    = "strike_immunity"
end


class "wound_immunity" ( hit_immunity )
function wound_immunity:__init() super()
  self.max     = 5
  self.new_hit = { "bleeding", "health" }
  self.sect    = "wound_immunity"
end


class "burn_immunity" ( hit_immunity )
function burn_immunity:__init() super()
  self.max     = 5
  self.sect    = "burn_immunity"
end


class "chemical_burn_immunity" ( hit_immunity )
function chemical_burn_immunity:__init() super()
  self.max     = 5
  self.new_hit = { "bleeding" }
  self.sect    = "chemical_burn_immunity"
end


class "shock_immunity" ( hit_immunity )
function shock_immunity:__init() super()
  self.max     = 2.5
  self.sect    = "shock_immunity"
end


class "radiation_immunity" ( hit_immunity )
function radiation_immunity:__init() super()
  self.max     = 25
  self.new_hit = { "radiation" }
  self.sect    = "radiation_immunity"
end


class "telepatic_immunity" ( hit_immunity )
function telepatic_immunity:__init() super()
  self.max     = 2.5
  self.sect    = "telepatic_immunity"
end


class "bleeding_restore_speed" ( restore_speed_pos )
function bleeding_restore_speed:__init() super()
  self.max     = 2.5
  self.sect    = "bleeding_restore_speed"
end


class "health_restore_speed" ( restore_speed_pos )
function health_restore_speed:__init() super()
  self.max     = 2.5
  self.sect    = "health_restore_speed"
end


class "power_restore_speed" ( restore_speed_pos )
function power_restore_speed:__init() super()
  self.max     = 125
  self.sect    = "power_restore_speed"
end


class "radiation_restore_speed" ( restore_speed_neg )
function radiation_restore_speed:__init() super()
  self.max     = 75
  self.sect    = "radiation_restore_speed"
end


class "satiety_restore_speed" ( restore_speed_pos )
function satiety_restore_speed:__init() super()
  self.max     = 5
  self.sect    = "satiety_restore_speed"
end


class "additional_inventory_weight2" ( self_absorbation )
function additional_inventory_weight2:__init()
  self.max     = 950400         -- 24 часа для Булыжника (11 кг.)
  self.sect    = "additional_inventory_weight2"
end
