-- -*- mode: lua; coding: windows-1251-dos -*-

-- величина разряда
local step = 0.007
-- как часто выполняется разряд фонарика ( в милисекундах реального времени )
local freq = 31 * 1000


function attach( sm )
  sm:subscribe({ signal = "on_first_update", fun = this.set_torch_mode })
  sm:subscribe({ signal = "on_key_down",     fun = this.on_key_down    })
  sm:subscribe({ signal = "on_mm_return_game", fun = this.on_mm_return_game })
  sm:subscribe({ signal = "on_sleep_finished", fun = this.on_sleep_finished })
  sm:subscribe({ signal = "on_spawn",        fun = this.on_spawn       })
  sm:subscribe({ signal = "on_update",       fun = this.on_update      })
end


function on_spawn()
  rebind_use_torch()
end


local dik_use_torch
function rebind_use_torch()
  dik_use_torch = {}
  local data = dsh_cfg.get_data()
  if not data.torch then return end
  for _, kn in ipairs( parse_names( data.torch ) ) do
    local dik = keyname_to_dik( kn )
    ASSERT( dik, "keyname to dik not found: %s", kn )
    dik_use_torch[ dik ] = true
  end
  cmd( "unbind torch" )
  cmd( "unbind_sec torch" )
end


function on_mm_return_game()
  rebind_use_torch()
end


local torch_mode = "off"
function set_torch_mode( k )
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      torch = get_torch_obj( torch )
      if torch.on then
        torch_mode = ogse.load_var( "dsh_torch.torch_mode", "near" )
        if torch_mode == "far" then
          set_far_mode( torch, k )
        elseif torch_mode == "near" then
          set_near_mode( torch, k )
        end
      else
        set_near_mode( torch, k )
        torch_mode = "off"
      end
    end
  end
end


function on_key_down( key, bind )
  if
    ( not dik_use_torch[ key ] ) or level.main_input_receiver() or db.eat
  then
    return
  end
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      local snd = sound_object( "device\\nlc6\\pda\\dairy_click_1" )
      snd:play( db.actor, 0, sound_object.s2d )
      torch = get_torch_obj( torch )
      if torch.on then
        if torch_mode == "near" then
          set_far_mode( torch )
        else
          torch:switch( false )
          torch_mode = "off"
        end
      else
        set_near_mode( torch )
        torch:switch( true )
      end
      ogse.save_var( "dsh_torch.torch_mode", torch_mode )
    end
  end
end


function set_near_mode( torch, r )
  torch_mode = "near"
  local g, b
  if r then
    g, b = r, r
  else
    r, g, b = get_torch_rgb()
  end
  torch:set_range( 20 * r )
  torch:set_angle( math.rad( 110 ) )
  torch:set_rgb( r, g, b )
  torch:set_brightness( 255 )
end


function set_far_mode( torch, r )
  torch_mode = "far"
  local g, b
  if r then
    g, b = r, r
  else
    r, g, b = get_torch_rgb()
  end
  torch:set_range( 60 * r )
  torch:set_angle( math.rad( 60 ) )
  torch:set_rgb( r, g, b )
  torch:set_brightness( 255 )
end


function is_torch_enabled()
  if db.actor:alive() then
    local torch = db.actor:item_in_slot( 9 )
    if torch and torch:is_torch() then
      torch = get_torch_obj( torch )
      return torch.on
    end
  end
end


function play_click()
  snd_obj = xr_sound.get_safe_sound_object( [[device\click10b]] )
  if snd_obj then
    snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0 )
  end
end


function get_torch_power( new )
  local vname = "dsh_torch.power"
  local power = ogse.load_var( vname, 0.9 )
  if new then
    ogse.save_var( vname, new, "float" )
  end
  return power
end


function get_torch_rgb()
  local power  = get_torch_power()
  local mode_k = torch_mode == "near" and 1 or 2
  local r_old  = power + ( mode_k - 1 ) * 0.1
  local r_new, g_new = r_old, r_old - 0.07
  return r_new, g_new, g_new
end


function recharge_torch( cond )
  if not cond then cond = 1 end
  get_torch_power( 0.9 * cond )
  set_torch_mode()
end


local flash_t
function discharge_torch()
  if torch_mode == "off" then return end
  local power = get_torch_power()
  if math.random() < 0.35 then
    set_torch_mode( power * ( math.random( 3, 10 ) ) / 10 )
    if flash_t then flash_t:stop() end
    flash_t = dsh.timeout(
      math.random( 3 ) * 1000,
      function()
        flash_t = nil
        discharge_torch()
      end
    )
  else
    if power > 0.01 then
      local mode_k = torch_mode == "near" and 1 or 2
      get_torch_power( power - ( step * ( mode_k * 2 ) ) )
    end
    set_torch_mode()
  end
end


local started = false
function on_update()
  ogse_signals.get_mgr():reschedule( freq )
  if started then
    discharge_torch()
  else
    started = true
  end
end


function on_sleep_finished( sleep_time )
  if torch_mode == "off" then return end
  get_torch_power( 0.13 )
  set_torch_mode()
end
