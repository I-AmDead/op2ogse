-- -*- mode: lua; coding: windows-1251-dos -*-

local def_trade_cfg = "misc\\trade_generic.ltx"


function attach( sm )
  sm:subscribe({ signal = "on_monster_death",       fun = this.on_death   })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_destroy })
  sm:subscribe({ signal = "on_npc_death",           fun = this.on_death   })
  sm:subscribe({ signal = "on_npc_net_destroy",     fun = this.on_destroy })
  sm:subscribe({ signal = "on_trade_open", fun = this.on_trade_open })
  sm:subscribe({ signal = "on_trade",      fun = this.on_trade      })
  sm:subscribe({ signal = "on_trade_hide", fun = this.on_trade_hide })
  sm:subscribe({ signal = "on_trade_money", fun = this.on_trade_money })
end


function on_death( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ "trade_manager.subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ "trade_manager.subscribed" ] = nil
  end
end


function on_destroy( obj, binder )
  local subscribed = binder[ "trade_manager.subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
    binder[ "trade_manager.subscribed" ] = nil
  end
  cleanup( obj )
end


local sold_items    = {}
local trade_manager = {}

function on_trade_open( npc )
  sold_items = {}
end


function on_trade( item, is_sold, money )
  if is_sold then
    table.insert( sold_items, item:id() )
  end
end


function on_trade_hide( npc )
  for _, id in ipairs( sold_items ) do
    local obj = level.object_by_id( id )
    if obj then
      local trader = obj:parent()
      if trader then
        local tt = trade_manager[ trader:id() ]
        if tt and tt.buy_supplies then
          ogse.remove_item_from_inventory( obj, trader )
        end
      end
    end
  end
  sold_items = {}
end


function on_trade_money( trader, money_out, money_in )
  ASSERT(
    trader:is_trader() or trader:is_stalker(),
    "[%s]: %s isn't trader or stalker", script_name(), trader:name()
  )
  local tt = trade_manager[ trader:id() ]
  if tt and tt.buy_supplies and money_out > 0 then
    local add_goodwill = math.floor( money_out / 1000 )
    if add_goodwill > 0 then
      local g_goodwill   = trader:general_goodwill( db.actor )
      local p_goodwill   = trader:goodwill( db.actor )
      trader:change_goodwill( add_goodwill, db.actor )
      log2(
        "[%s]: %s goodwill[%s -> %s] general_goodwill[%s -> %s]",
        script_name(), trader:name(), p_goodwill, trader:goodwill( db.actor ),
        g_goodwill, trader:general_goodwill( db.actor )
      )
    end
  end
end


function trade_init( npc, cfg )
  local tt = {}
  trade_manager[ npc:id() ] = tt
  -- log2( "TRADE INIT[%s]: %s", npc:name(), tostring( cfg ) )
  if not cfg then
    cfg = def_trade_cfg
  end
  tt.cfg_ltx = cfg
  tt.config  = dsh.cached_ini_file( tt.cfg_ltx )

  -- коэфициенты покупки
  local str = get_string( "trader", "buy_condition", nil, tt.config )
  ASSERT(
    str,
   "Incorrect trader settings. Cannot find buy_condition. [%s]->[%s]",
   npc:name(), cfg
  )
  tt.buy_condition = xr_logic.parse_condlist(
    npc, "trade_manager", "buy_condition", str
  )

  -- коэфициенты продажи
  str = get_string( "trader", "sell_condition", nil, tt.config )
  ASSERT(
    str,
    "Incorrect trader settings. Cannot find sell_condition. [%s]->[%s]",
    npc:name(), cfg
  )
  tt.sell_condition = xr_logic.parse_condlist(
    npc, "trade_manager", "sell_condition", str
  )

  -- список закупки
  str = get_string( "trader", "buy_supplies", nil, tt.config )
  if str then
    tt.skip_updates = 10
    tt.buy_supplies = xr_logic.parse_condlist(
      npc, "trade_manager", "buy_supplies", str
    )
    local sobj = alife():object( npc:id() )
    if sobj then
      local ini  = sobj:spawn_ini()
      local sect = "trade_manager"
      if ini:section_exist( sect ) then
        local resuply_time = get_string( sect, "resuply_time", nil, ini )
        if resuply_time then
          tt.resuply_time = unpack_time_from_string( resuply_time )
          -- log2(
          --   "TRADE INIT[%s] resuply_time in %s seconds",
          --   npc:name(), tt.resuply_time:diffSec( game.get_game_time() )
          -- )
        end
      end
    end
  else
    tt.buy_supplies = nil
  end

  if npc:alive() then
    local binder = npc:binded_object()
    if not binder[ "trade_manager.subscribed" ] then
      local s = {
        [ "signal" ] = "on_update",
        [ "self"   ] = npc,
        [ "fun"    ] = this.update,
      }
      binder[ "trade_manager.subscribed" ] = s
      ogse_signals.get_mgr():subscribe( s )
    end
  end
end


function cleanup( obj )
  trade_manager[ obj:id() ] = nil
end


function update( npc )
  local tt = trade_manager[ npc:id() ]
  ASSERT( tt, "trade_manager[ npc:id() ] npc found: %s", npc:name() )

  if tt.skip_updates and tt.skip_updates > 0 then
    tt.skip_updates = tt.skip_updates - 1
    return
  end
  if tt.noupdate then return end

  local str = xr_logic.pick_section_from_condlist(
    db.actor, npc, tt.buy_condition
  )
  if tt.current_buy_condition ~= str then
    -- log2( "TRADE UPDATE[%s]: buy condition = %s", npc:name(), str )
    npc:buy_condition( tt.config, str )
    tt.current_buy_condition = str
  end

  str = xr_logic.pick_section_from_condlist( db.actor, npc, tt.sell_condition )
  if tt.current_sell_condition ~= str then
    -- log2( "TRADE UPDATE[%s]: sell condition = %s", npc:name(), str )
    npc:sell_condition( tt.config, str )
    tt.current_sell_condition = str
  end

  if not tt.buy_supplies then
    -- это обычный сталкер, у которого нет товара, значит и обновлять
    -- нечего. Инициализировали покупку/продажу и можно отписаться от
    -- апдейта.
    on_death( npc )
  end

  local update_t = math.random( 10, 60 ) * 1000
  ogse_signals.get_mgr():reschedule( update_t )

  if
    tt.resuply_time
    and tt.resuply_time:diffSec( game.get_game_time() ) > 0
  then
    return
  end

  str = xr_logic.pick_section_from_condlist(db.actor, npc, tt.buy_supplies )
  if tt.current_buy_supplies ~= str then
    -- log2( "TRADE UPDATE[%s]: buy_supplies = %s", npc:name(), str )
    npc:buy_supplies( tt.config, str )
    add_buy_supplies( npc, tt.config, str )
    tt.current_buy_supplies = str
  end
  tt.resuply_time = game.get_game_time()
    + seconds2ctime( math.random( 12, 24 ) * 3600 )
  -- log2(
  --   "TRADE UPDATE[%s] resuply_time in %s seconds",
  --   npc:name(), tt.resuply_time:diffSec( game.get_game_time() )
  -- )
  local sobj = alife():object( npc:id() )
  if sobj then
    local ini  = sobj:spawn_ini()
    local sect = "trade_manager"
    ini.readonly = false
    ini:w_string(
      sect, "resuply_time", pack_time_to_string( tt.resuply_time )
    )
    sobj:save_spawn_ini()
    -- log2( "TRADE UPDATE[%s] custom_data = %s", npc:name(), sobj.custom_data )
  end
end


function save( obj, packet )
  local tt = trade_manager[ obj:id() ]

  --' Сохраняем присутствует ли инициализированная торговля в принципе.
  if tt then
    packet:w_bool( true )
  else
    -- log2( "TRADE SAVE[%s]: ignored", obj:name() )
    packet:w_bool( false )
    return
  end

  packet:w_stringZ( tt.cfg_ltx )

  -- log2(
  --   "TRADE SAVE[%s]: current_buy_condition = %s",
  --   obj:name(), tostring( tt.current_buy_condition )
  -- )
  if tt.current_buy_condition then
    packet:w_stringZ( tt.current_buy_condition )
  else
    packet:w_stringZ( "" )
  end

  -- log2(
  --   "TRADE SAVE[%s]: current_sell_condition = %s",
  --   obj:name(), tostring( tt.current_sell_condition )
  -- )
  if tt.current_sell_condition then
    packet:w_stringZ( tt.current_sell_condition )
  else
    packet:w_stringZ( "" )
  end

  -- log2(
  --   "TRADE SAVE[%s]: current_buy_supplies = %s",
  --   obj:name(), tostring( tt.current_buy_supplies )
  -- )
  if tt.current_buy_supplies then
    packet:w_stringZ( tt.current_buy_supplies )
  else
    packet:w_stringZ( "" )
  end

  packet:w_s32( -1 )
  packet:w_s32( -1 )
end


function load( obj, packet )
  local a = packet:r_bool()
  if a == false then
    -- log2( "TRADE LOAD[%s]: ignored", obj:name() )
    return
  end

  local tt = {}
  trade_manager[ obj:id() ] = tt

  tt.cfg_ltx = packet:r_stringZ()
  -- log2( "TRADE LOAD[%s]: cfg_ltx = %s", obj:name(), tostring( tt.cfg_ltx ) )
  tt.config = dsh.cached_ini_file( tt.cfg_ltx )

  a = packet:r_stringZ()
  -- log2(
  --   "TRADE LOAD[%s]: current_buy_condition = %s", obj:name(), tostring( a )
  -- )
  if a ~= "" then
    tt.current_buy_condition = a
    obj:buy_condition( tt.config, a )
  end

  a = packet:r_stringZ()
  -- log2(
  --   "TRADE LOAD[%s]: current_sell_condition = %s", obj:name(), tostring( a )
  -- )
  if a ~= "" then
    tt.current_sell_condition = a
    obj:sell_condition( tt.config, a )
  end

  a = packet:r_stringZ()
  -- log2(
  --   "TRADE LOAD[%s]: current_buy_supplies = %s", obj:name(), tostring( a )
  -- )
  if a ~= "" then tt.current_buy_supplies = a end

  packet:r_s32()
  packet:r_s32()
end


function add_buy_supplies( npc, ini, def_sect )
  local sect = def_sect .. ".add"
  if ini:section_exist( sect ) then
    for i = 0, ini:line_count( sect ) - 1 do
      local _, key, v = ini:r_line( sect, i )
      local n = math.random( 0, tonumber( v ) )
      if n > 0 then
        for j = 1, n do
          ogse.spawn_item_in_inv( key, npc )
        end
      end
    end
  end
end


function get_cfg( npc )
  return trade_manager[ npc:id() ]
end


local actor_money = -1
local vcost = math.random( 500, 2000 )

function tradein_start( npc, buy, sell )
  local tt = get_cfg( npc )
  ASSERT( tt, "trade_manager[ npc:id() ] npc found: %s", npc:name() )
  tt.noupdate = true
  actor_money = db.actor:money()
  db.actor:set_money( 0 )

  -- коэфициенты покупки
  if not tt[ buy ] then
    local str = get_string( "trader", buy, nil, tt.config )
    ASSERT( str, "[%s]: %s: %s not found", script_name(), npc:name(), buy )
    tt[ buy ] = xr_logic.parse_condlist( npc, "trade_manager", buy, str )
  end
  ASSERT( tt[ buy ], "[%s]: %s: %s not found", script_name(), npc:name(), buy )
  npc:buy_condition(
    tt.config, xr_logic.pick_section_from_condlist( db.actor, npc, tt[ buy ] )
  )

  -- коэфициенты продажи
  if not tt[ sell ] then
    local str = get_string( "trader", sell, nil, tt.config )
    ASSERT( str, "[%s]: %s: %s not found", script_name(), npc:name(), sell )
    tt[ sell ] = xr_logic.parse_condlist( npc, "trade_manager", sell, str )
  end
  ASSERT( tt[ sell ], "[%s]: %s: %s not found", script_name(), npc:name(), sell )
  npc:sell_condition(
    tt.config, xr_logic.pick_section_from_condlist( db.actor, npc, tt[ sell ] )
  )

  npc:trade_virtual_cost( vcost, true )
  npc:ignore_trade_cond_factor( true )
  ogse_signals.get_mgr():subscribe(
    {
      [ "signal" ] = "on_trade_hide",
      [ "self"   ] = npc,
      [ "fun"    ] = this.tradein_stop,
    }
  )
  db.actor:switch_to_trade()
end


function tradein_stop( npc )
  local tt = get_cfg( npc )
  ASSERT( tt, "trade_manager[ npc:id() ] npc found: %s", npc:name() )

  npc:trade_virtual_cost( 0, false )
  npc:ignore_trade_cond_factor( false )
  npc:buy_condition( tt.config, tt.current_buy_condition )
  npc:sell_condition( tt.config, tt.current_sell_condition )
  tt.noupdate = nil

  if actor_money >= 0 then
    db.actor:set_money( actor_money )
    actor_money = -1
  end
end


function voron_tradein( npc1, npc2 )
  local npc = npc1:is_actor() and npc2 or npc1
  tradein_start( npc, "buy_psevdodog_tail", "sell_psevdodog_tail" )
end


function marsh_dan_tradein( npc1, npc2 )
  local npc = npc1:is_actor() and npc2 or npc1
  tradein_start( npc, "buy_mutant_parts", "sell_mutant_parts" )
end
