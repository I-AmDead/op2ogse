-- -*- mode: lua; coding: windows-1251-dos -*-
-- ************************************************
-- **                    Imp                     **
-- **       Биндер самодельных телепортов        **
-- ** Поддерживает работу самопальных телепортов **
-- **    Proper70 доработано для поддержания     **
-- **    функций рестриктора и выдачи поршней,   **
-- **    а также поддержки формы телепорта box   **
-- ************************************************

-- Proper70 в конфиг добавлены параметры для поддержания функций
-- рестриктора и выдачи поршней:
--
-- info = vzn_temp1 -- есди задано - выдается этот поршень
--
-- func = kostya_dialog.give_ammo(1)-- если задано - вызывается эта
-- функция с указанными параметрами, все писать без пробелов.
--
-- для создания телепорта в форме box в конфиге можно задавать 3 параметра:
-- x_radius, y_radius, z_radius. z_radius = высота.


function abs_comp( a, b )
  -- Служебная функция вычисления разности
  if a < b then
    return b - a
  else
    return a - b
  end
end


function bind( obj )
  obj:bind_object( restrictor_teleport( obj ) )
end


class "restrictor_teleport" ( object_binder )
function restrictor_teleport:__init( obj ) super( obj )
  self.sm = ogse_signals.get_mgr()
  self.teleporting = false
end


function restrictor_teleport:net_spawn( sobj )
  if not object_binder.net_spawn( self, sobj ) then
    return false
  end
  local sect = self.object:section()
  if not get_bool( sect, "teleport" ) then return true end
  -- Заполним таблицу параметров
  self.parametrs = {}
  local t = self.parametrs
  if sys_ini:line_exist( sect, "radius" ) then
    t.x_radius = get_float( sect, "radius" )
    t.y_radius = get_float( sect, "radius" )
  else
    t.x_radius = 2 -- Дефолтный радиус по xy
    t.y_radius = 2 -- Дефолтный радиус по xy
  end
  if sys_ini:line_exist( sect, "z_radius" ) then
    t.z_radius = get_float( sect, "z_radius" )
  else
    -- если радиус высоты не задан то задаем равным радиусу xy
    t.z_radius = t.x_radius
  end
  --  параметры box
  if sys_ini:line_exist( sect, "x_radius" ) then
    t.x_radius = get_float( sect, "x_radius" )
  end
  if sys_ini:line_exist( sect, "y_radius" ) then
    t.y_radius = get_float( sect, "y_radius" )
  end
  -- Запомним позицию что-бы каждый раз не считать
  local pos = self.object:position()
  t.x = pos.x
  t.y = pos.y
  t.z = pos.z
  -- Запомним координаты куда телепортимся
  t.pos_rnd_radius = get_float( sect, "pos_rnd_radius" )
  t.poz_rnd = get_u32( sect, "poz_rnd" )
  local s   = t.poz_rnd and math.random( t.poz_rnd ) or ""
  t.poz_x   = get_float( sect, "poz_x" .. s )
  t.poz_y   = get_float( sect, "poz_y" .. s )
  t.poz_z   = get_float( sect, "poz_z" .. s )
  t.rotate  = get_float( sect, "rotate" )
  -- Функции рестриктора
  -- выдать поршень
  t.info = get_string( sect, "info" )
  -- выполнить функцию
  t.func = get_string( sect, "func" )
  local cond = get_string( sect, "cond" )
  if cond then
    t.cond = xr_logic.parse_condlist( self.object, sect, "cond", cond )
  end
  self.object:set_callback( callback.zone_enter, self.on_enter, self )
  if self.object:get_shape_radius() <= 1 then
    self.subscribed = {
      [ "signal" ] = "on_update",
      [ "fun"    ] = self.actor_update,
      [ "self"   ] = self,
      [ "script_name" ] = "bind_mteleport.actor_update",
    }
    self.sm:subscribe( self.subscribed )
  end
  if amk_anoms.is_generated_anomaly( sobj ) then
    self.is_generated_anomaly = true
    amk_anoms.add_anomaly(
      sobj.id, sobj.position, self.object:get_shape_radius(), sobj
    )
    self.sm:call( "on_anomaly_spawn", self.object, self )
  end
  return true
end


function restrictor_teleport:net_destroy()
  self.object:set_callback( callback.zone_enter, nil )
  if self.subscribed then
    self.sm:unsubscribe( self.subscribed )
    self.subscribed = nil
  end
  if self.is_generated_anomaly then
    amk_anoms.remove_anomaly( self.object:id() )
    self.sm:call( "on_anomaly_net_destroy", self.object, self )
  end
  object_binder.net_destroy( self )
end


function restrictor_teleport:on_enter( zone, obj )
  if not obj:is_actor() then return end
  if self.teleporting   then return end
  local s = self.parametrs
  if
    s.cond
    and xr_logic.pick_section_from_condlist(
      db.actor, self.object, s.cond
    ) == nil
  then
    return
  end
  if s.pos_rnd_radius then
    local pos = dsh.get_random_pos_in_radius( s.pos_rnd_radius, 25 )
    if pos then
      s.poz_x, s.poz_y, s.poz_z = pos.x, pos.y, pos.z
    else
      return
    end
  end
  -- Актер в зоне действия телепорта, запустим телепорт
  self:actor_pre_teleport()
end


function restrictor_teleport:actor_pre_teleport()
  self.teleporting = true
  level.disable_input()
  -- Запускаем спецэфекты телепортации
  level.add_pp_effector( "teleport.ppe", 2006, false )
  dsh.timeout( 1000, self.actor_teleport, self )
end


function restrictor_teleport:actor_teleport()
  local s = self.parametrs
  -- Телепорт запущен
  local pos = db.actor:position()
  ogse.save_var(
    "bind_mteleport.orig_pos", { pos.x, pos.y, pos.z }, "vector"
  )
  db.actor:set_actor_position( vector():set( s.poz_x, s.poz_y, s.poz_z ) )
  if s.rotate then
    db.actor:set_actor_direction( s.rotate )
  end
  -- выполняем функции рестриктора
  if s.info then
    -- выдаем поршень
    db.actor:give_info_portion( s.info )
  end
  if s.func then
    -- выполняем функцию
    local f, err = loadstring( s.func )
    ASSERT( f, err )
    f()
  end
  -- Звуковое сопровождение
  local snd_obj = xr_sound.get_safe_sound_object( "anomaly\\teleport_work_1" )
  snd_obj:play_no_feedback(
    db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0
  )
  level.enable_input()
  dsh.timeout( 1, function() self.teleporting = false end )
end


function restrictor_teleport:actor_is_inside()
  local acter_poz = db.actor:position()
  local s = self.parametrs
  return
    abs_comp( s.x, acter_poz.x ) < s.x_radius
    and abs_comp( s.z, acter_poz.z ) < s.y_radius
    and abs_comp( s.y, acter_poz.y ) < s.z_radius
    and (
      ( not s.cond )
      or xr_logic.pick_section_from_condlist(
        db.actor, self.object, s.cond
      ) ~= nil
    )
end


function restrictor_teleport:actor_update()
  if ( not self.teleporting ) and self:actor_is_inside() then
    -- Проверим не забрел ли актор в наш телепорт
    local can_teleport = true
    local s = self.parametrs
    if s.pos_rnd_radius then
      local pos = dsh.get_random_pos_in_radius( s.pos_rnd_radius, 25 )
      if pos then
        s.poz_x, s.poz_y, s.poz_z = pos.x, pos.y, pos.z
      else
        can_teleport = false
      end
    end
    if can_teleport then
      -- Актер в зоне действия телепорта, запустим телепорт
      self:actor_pre_teleport()
      self.sm:reschedule( 2000 )
      return
    end
  end
  local dist = self.object:position():distance_to( db.actor:position() )
  self.sm:reschedule(
    ( dist < 25 and 200 ) or ( dist < 100 and 1000 )
    or math.random( 5000, 6000 )
  )
end
