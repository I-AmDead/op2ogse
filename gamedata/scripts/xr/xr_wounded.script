-- -*- mode: lua; coding: windows-1251-dos -*-
--  Схема раненного
--  автор: Диденко Руслан (Stohe)
--  TODO:

medkits = {
  "medkit_army",
  "medkit_scientic",
  "medkit",
}

local dont_shoot = {
  [ "bandit_1"   ] = "characters_voice\\human_01\\bandit\\states\\panic_human\\panic_human_1",
  [ "bandit_2"   ] = "characters_voice\\human_01\\bandit\\states\\panic_human\\panic_human_2",
  [ "bandit_3"   ] = "characters_voice\\human_01\\bandit\\states\\panic_human\\panic_human_6",
  [ "bandit_4"   ] = "characters_voice\\human_01\\bandit\\states\\panic_human\\panic_human_7",
  [ "bandit_5"   ] = "characters_voice\\human_01\\bandit\\states\\panic_human\\panic_human_8",
  [ "ecolog_1"   ] = "characters_voice\\human_01\\ecolog\\states\\panic_human\\panic_1",
  [ "ecolog_2"   ] = "characters_voice\\human_01\\ecolog\\states\\panic_human\\panic_2",
  [ "ecolog_3"   ] = "characters_voice\\human_01\\ecolog\\states\\panic_human\\panic_4",
  [ "ecolog_4"   ] = "characters_voice\\human_01\\ecolog\\states\\panic_human\\panic_5",
  [ "freedom_1"  ] = "characters_voice\\human_01\\freedom\\states\\panic_human\\panic_human_1",
  [ "freedom_2"  ] = "characters_voice\\human_01\\freedom\\states\\panic_human\\panic_human_2",
  [ "freedom_3"  ] = "characters_voice\\human_01\\freedom\\states\\panic_human\\panic_human_3",
  [ "freedom_4"  ] = "characters_voice\\human_01\\freedom\\states\\panic_human\\panic_human_4",
  [ "killer_1"   ] = "characters_voice\\human_01\\killer\\states\\panic_human\\panic_1",
  [ "killer_2"   ] = "characters_voice\\human_01\\killer\\states\\panic_human\\panic_2",
  [ "killer_3"   ] = "characters_voice\\human_01\\killer\\states\\panic_human\\panic_3",
  [ "military_1" ] = "characters_voice\\human_01\\military\\states\\panic_human\\panic_human_1",
  [ "military_2" ] = "characters_voice\\human_01\\military\\states\\panic_human\\panic_human_2",
  [ "military_3" ] = "characters_voice\\human_01\\military\\states\\panic_human\\panic_human_3",
  [ "military_4" ] = "characters_voice\\human_01\\military\\states\\panic_human\\panic_human_5",
  [ "monolith_1" ] = "characters_voice\\human_01\\monolith\\states\\panic_human\\panic_1",
  [ "monolith_2" ] = "characters_voice\\human_01\\monolith\\states\\panic_human\\panic_2",
  [ "monolith_3" ] = "characters_voice\\human_01\\monolith\\states\\panic_human\\panic_3",
  [ "newbie_1"   ] = "characters_voice\\human_01\\newbie\\states\\panic_human\\panic_human_1",
  [ "newbie_2"   ] = "characters_voice\\human_01\\newbie\\states\\panic_human\\panic_human_2",
  [ "newbie_3"   ] = "characters_voice\\human_01\\newbie\\states\\panic_human\\panic_human_3",
  [ "newbie_4"   ] = "characters_voice\\human_01\\newbie\\states\\panic_human\\panic_human_4",
  [ "stalker_1"  ] = "characters_voice\\human_01\\stalker\\states\\panic_human\\panic_human_3",
  [ "stalker_2"  ] = "characters_voice\\human_01\\stalker\\states\\panic_human\\panic_human_4",
  [ "stalker_3"  ] = "characters_voice\\human_01\\stalker\\states\\panic_human\\panic_human_6",
}


pseudo_wounded = {
  -- фотография в X-16
  [ "foto_monolitovets"      ] = true,
  -- фотография Монолита в Саркофаге
  [ "nevid_monolit"          ] = true,
  -- фотография на АС
  [ "military_fotomuzhik"    ] = true,
  [ "milit_zapas_fotomuzhik" ] = true,
  -- фотография на Кордоне
  [ "esc_foto_muzhik"        ] = true,
  [ "zapasnoy_foto_muzhik"   ] = true,
  -- Монгол
  [ "val_escort_bandit_halfdead" ] = {
    [ "until_info" ] = "val_bandit_talk",
  },
}


-- Как монолитовцы, будут на ногах до последнего.
like_monolith = {
  -- Гавр и его охрана
  [ "mil_trader_gavr"     ] = true,
  [ "mil_gavr_bodyguard1" ] = true,
  [ "mil_gavr_bodyguard2" ] = true,
}


-- спец. обработка после лечения аптечкой
local special_help_wounded = {
  -- сумашедший на АС
  [ story_ids.Mil_Crazy ] = true
}


local beg_timer       = time_global()
local beg_check_timer = {}


function is_pseudo_wounded( k )
  local d = pseudo_wounded[ k ]
  if d then
    if type( d ) == "table" then
      if d.until_info then
        return db.actor:dont_has_info( d.until_info )
      end
    end
    return true
  end
  return false
end


function is_special_help_wounded( npc )
  if special_help_wounded[ npc:story_id() ] then return true end
  return false
end


class "evaluator_wound" ( property_evaluator )
function evaluator_wound:__init( name, storage ) super( nil, name )
  self.a = storage
end


function evaluator_wound:evaluate()
  local npc = self.object
  if not self.a.wounded_set then return false end
  if not self.a.regen then
    if not is_pseudo_wounded( npc:name() ) then
      self.a.regen = npc:character_community() == "zombied"
        or npc:character_community() == "monolith"
    end
  end

  local sobj = alife():object( npc:id() )
  if
    npc.health > 0.95 and self.a.regen
    and tostring( xr_logic.pstor_retrieve( npc, "wounded_state" ) ) ~= "nil"
  then
    if sobj then sobj.wounded = false end
    self.a.wound_manager:hit_callback()
  elseif
    tostring( xr_logic.pstor_retrieve( npc, "wounded_state" ) ) == "nil"
    and sobj and sobj.wounded
  then
    self.a.wound_manager:hit_callback()
  end

  if tostring( xr_logic.pstor_retrieve( npc, "wounded_state" ) ) ~= "nil" then
    ogse_debug.add_active_eval( self.object, script_name(), "wounded" )
    return true
  end
  return false
end


class "evaluator_can_fight" ( property_evaluator )
function evaluator_can_fight:__init( name, storage ) super( nil, name )
  self.a = storage
end


function evaluator_can_fight:evaluate()
  if self.object:critically_wounded() then
    ogse_debug.add_active_eval(
      self.object, script_name(), "wounded_can_fight"
    )
    return true
  end

  return xr_logic.pstor_retrieve( self.object, "wounded_fight" ) ~= "false"
end


class "action_wounded" ( action_base )
function action_wounded:__init( name, storage ) super( nil, name )
  self.a = storage
end


function action_wounded:initialize()
  action_base.initialize( self )
  self.object:set_desired_position()
  self.object:set_desired_direction()
  self.sound = "nil"

  if self.a.help_start_dialog then
    self.object:set_start_dialog( self.a.help_start_dialog )
  end
  -- if not self.a.regen then self.object:wounded( true ) end
  self.object:wounded( true )
  news_main.on_wound( self.object )
  ogse_signals.get_mgr():call( "on_wounded", self.object )
end


function action_wounded:execute()
  action_base.execute( self )
  local wound_manager  = self.a.wound_manager
  wound_manager_victim = xr_logic.pstor_retrieve(
    self.object, "wounded_victim"
  )

  local victim
  if wound_manager_victim == "actor" then
    victim = db.actor
  elseif tostring( wound_manager_victim ) ~= "nil" then
    victim = alife():story_object( victim )
  end

  if
    self.object:character_community() == "monolith"
    or self.object:character_community() == "zombied"
  then
    self.object:disable_talk()
  else
    self.object:enable_talk()
  end

  local wound_manager_state = xr_logic.pstor_retrieve(
    self.object, "wounded_state"
  )
  local wound_manager_sound = xr_logic.pstor_retrieve(
    self.object, "wounded_sound"
  )

  local synsound
  if wound_manager_state == "true" then
    local h = hit()
    h.power     = 0
    h.direction = self.object:direction()
    h.bone      = "bip01_spine"
    h.draftsman = db.actor
    h.impulse   = 0
    h.type      = hit.wound
    self.object:hit( h )
  else
    -- является ли текущий звук синхронным для текущего стейта
    for k, v in pairs( self.a.syndata ) do
      if
        v.state == wound_manager_state
        and v.sound == wound_manager_sound
      then
        synsound = wound_manager_sound
      end
    end
    -- жрание аптечек и прочей срани.
    -- Использовать можно только если нам можно сейчас есть аптечку.
    if self.a.use_medkit then
      wound_manager:eat_medkit()
    end
    local emerg
    if wound_manager_state == "psy_shoot" then
      emerg = { animation_nout = true }
    end
    xrs_medic.add_wounded( self.object )
    if not wound_manager_state or wound_manager_state == "nil" then
      wound_manager_state = "wounded"
    end
    state_mgr.set_state(
      self.object, wound_manager_state, nil, nil, { look_object = victim },
      emerg, synsound
    )
  end

  if not synsound then
    -- нужно отыграть фоновый
    if self.sound ~= wound_manager_sound then
      self.sound = wound_manager_sound
      if self.sound == "nil" then
        xr_sound.set_sound( self.object, nil )
      else
        xr_sound.set_sound( self.object, wound_manager_sound )
      end
    end
  else
    -- нужно зарубить фоновый
    if self.sound then
      self.sound = "nil"
      xr_sound.set_sound( self.object, nil )
    end
  end

  local tt = db.storage[ self.object:id() ]
  if tt.active_scheme and not self.object:is_talking() then
    if db.actor then
      local switched = xr_logic.try_switch_to_another_section(
        self.object, tt[ tt.active_scheme ], db.actor
      )
      if switched then return end
    end
  end
end


function action_wounded:finalize()
  action_base.finalize( self )
  local npc = self.object
  npc:disable_talk()
  xr_sound.set_sound( npc, nil )
  npc:wounded( false )
  xrs_medic.remove_wounded( npc )
  state_mgr.set_state( npc, "idle", nil, nil, nil, { animation = true } )
end


class "Cwound_manager"
function Cwound_manager:__init( npc, storage )
  self.npc            = npc
  self.a              = storage
  self.can_use_medkit = false
  self.medkit_eaten   = nil
end


function Cwound_manager:update()
  local hp   = 100 * self.npc.health
  local psy  = 100 * self.npc.psy_health
  local comm = self.npc:character_community()

  local sobj = alife():object( self.npc:id() )
  if not sobj then return end
  if sobj.wounded and ( not self.a.regen ) and ( not self.medkit_eaten ) then
    hp = 1                      -- симулируем раненость
  end

  if
    db.actor and comm ~= "ecolog" and comm ~= "trader" and comm ~= "zombied"
    and isWeapon( db.actor:active_item() )
    and self.npc:relation( db.actor ) == game_object.enemy
    and self.npc.health < 0.35
    and self.npc:position():distance_to( db.actor:position() ) < 10
    and self:actor_targets_npc( self.npc )
  then
    self.npc:disable_talk()
    stop_play_sound( self.npc )
    beg_check_timer[ self.npc:id() ] = time_global()
    if beg_check_timer[ self.npc:id() ] > beg_timer then
      -- играем звук
      local snd_name
      if comm == "bandit" then
        snd_name = dont_shoot[ "bandit_" .. tostring( math.random( 1, 5 ) ) ]
      elseif comm == "freedom" then
        snd_name = dont_shoot[ "freedom_" .. tostring( math.random( 1, 4 ) ) ]
      elseif comm == "killer" then
        snd_name = dont_shoot[ "killer_" .. tostring( math.random( 1, 3 ) ) ]
      elseif comm == "military" then
        snd_name = dont_shoot[ "military_" .. tostring( math.random( 1, 4 ) ) ]
      elseif comm == "monolith" then
        snd_name = dont_shoot[ "monolith_" .. tostring( math.random( 1, 3 ) ) ]
      elseif comm == "stalker" then
        local rank = get_npc_rank( self.npc )
        if rank and rank > 3 then
          snd_name = dont_shoot[ "newbie_" .. tostring( math.random( 1, 4 ) ) ]
        else
          snd_name = dont_shoot[ "stalker_" .. tostring( math.random( 1, 3 ) ) ]
        end
      end
      if snd_name then
        local snd_obj = xr_sound.get_safe_sound_object( snd_name )
        if snd_obj and not snd_obj:playing() then
          snd_obj:play_no_feedback(
            self.npc, sound_object.s3d, 0, self.npc:position(), 1.0
          )
        end
      end
      beg_timer = beg_check_timer[ self.npc:id() ] + math.random( 3000, 4000 )
    end
  else
    self.npc:enable_talk()
  end

  self.state, self.sound = self:process_psy_wound( psy )
  if self.state == "nil" and self.sound == "nil" then
    -- проверяем на обычную раненость
    self.fight  = self:process_fight(  hp )
    self.victim = self:process_victim( hp )
    self.state, self.sound = self:process_hp_wound( hp )
  else
    -- устанавливаем пси раненость
    self.fight  = "false"
    self.cover  = "false"
    self.victim = "nil"
  end

  xr_logic.pstor_store( self.npc, "wounded_state",  self.state  )
  xr_logic.pstor_store( self.npc, "wounded_sound",  self.sound  )
  xr_logic.pstor_store( self.npc, "wounded_fight",  self.fight  )
  xr_logic.pstor_store( self.npc, "wounded_victim", self.victim )

  if ( not self.state ) or self.state == "nil" then
    self.medkit_eaten = nil
    sobj.wounded = false
    self.npc:wounded( false )
    self.npc:enable_trade()
  else
    sobj.wounded = true
    self.npc:disable_trade()
    if self.npc:get_bleeding() <= 0 and self.npc.health > 0.2 then
      -- Нефиг тут внагляк лежать и выздоравливать если уложили
      self.npc.health = 0.2 - self.npc.health -- -0.0003
    end
  end
end


function Cwound_manager:unlock_medkit()
  self.can_use_medkit = true
  xrs_medic.remove_wounded( self.npc )
end


function Cwound_manager:eat_medkit()
  if self.can_use_medkit then
    local medkit_eaten = false
    local has_medkit
    for _, sect in ipairs( medkits ) do
      has_medkit = self.npc:object( sect )
      if has_medkit and alife():object( has_medkit:id() ) then
        break
      else
        has_medkit = nil
      end
    end
    if has_medkit then
      -- self.npc:eat( has_medkit )
      self.npc:heal_wounds( 1 )
      self.npc.health = 1
      ogse.remove_item_from_inventory( has_medkit, self.npc )
      medkit_eaten = true
    end
    if medkit_eaten then
      local sobj = alife():object( self.npc:id() )
      sobj.wounded        = false -- позволяем выйти из состояния раненности
      self.npc:wounded( false )
      self.medkit_eaten   = true
      self.can_use_medkit = false
    end
  end
  self:hit_callback()
end


function Cwound_manager:process_fight( hp )
  local key = self:get_key_from_distance( self.a.hp_fight, hp )
  if key then
    if self.a.hp_fight[ key ].state then
      return tostring(
        xr_logic.pick_section_from_condlist(
          db.actor, self.npc, self.a.hp_fight[ key ].state
        )
      )
    end
  end
  return "true"
end


function Cwound_manager:process_victim( hp )
  local key = self:get_key_from_distance( self.a.hp_victim, hp )
  if key then
    if self.a.hp_victim[ key ].state then
      return tostring(
        xr_logic.pick_section_from_condlist(
          db.actor, self.npc, self.a.hp_victim[ key ].state
        )
      )
    end
  end
  return "nil"
end


function Cwound_manager:process_hp_wound( hp )
  local key = self:get_key_from_distance( self.a.hp_state, hp )
  if key then
    local r1, r2
    if self.npc:see( db.actor ) then
      if self.a.hp_state_see[ key ].state then
        r1 = xr_logic.pick_section_from_condlist(
          db.actor, self.npc, self.a.hp_state_see[ key ].state
        )
      end
      if self.a.hp_state_see[ key ].sound then
        r2 = xr_logic.pick_section_from_condlist(
          db.actor, self.npc, self.a.hp_state_see[ key ].sound
        )
      end
    else
      if self.a.hp_state[ key ].state then
        r1 = xr_logic.pick_section_from_condlist(
          db.actor, self.npc, self.a.hp_state[ key ].state
        )
      end
      if self.a.hp_state[ key ].sound then
        r2 = xr_logic.pick_section_from_condlist(
          db.actor, self.npc, self.a.hp_state[ key ].sound
        )
      end
    end
    return tostring( r1 ), tostring( r2 )
  end
  return "nil", "nil"
end


function Cwound_manager:process_psy_wound( hp )
  local key = self:get_key_from_distance( self.a.psy_state, hp )
  if key then
    local r1, r2
    if self.a.psy_state[ key ].state then
      r1 = xr_logic.pick_section_from_condlist(
        db.actor, self.npc, self.a.psy_state[ key ].state
      )
    end
    if self.a.psy_state[ key ].sound then
      r2 = xr_logic.pick_section_from_condlist(
        db.actor, self.npc, self.a.psy_state[ key ].sound
      )
    end
    return tostring( r1 ), tostring( r2 )
  end
  return "nil", "nil"
end


function Cwound_manager:get_key_from_distance( t, hp )
  local key
  if ( not t ) or t == "" or t == "nil" then return nil end
  for k, v in pairs( t ) do
    if v.dist >= hp then
      key = k
    else
      return key
    end
  end
  return key
end


function Cwound_manager:hit_callback()
  if not self.npc:alive() then return end
  if self.npc:critically_wounded() then return end
  self:update()
end


function Cwound_manager:actor_targets_npc( npc )
  local dangerang = 1 / npc:position():distance_to( db.actor:position() )
  local ang = horz_angle(
    device().cam_dir, npc:position():sub( device().cam_pos )
  )
  local tgt = ang > -dangerang and ang < dangerang
  if tgt then
    if self.tgt_time then
      return self.tgt_time < time_global()
    else
      self.tgt_time = time_global() + 600
      return false
    end
  else
    self.tgt_time = nil
  end
  return false
end


function add_to_binder( object, ini, scheme, section, st )
  local operators     = {
    [ "wounded"   ] = xr_actions_id.sidor_act_wounded_base,
  }
  local properties    = {
    [ "wounded"   ] = xr_evaluators_id.sidor_wounded_base,
    [ "can_fight" ] = xr_evaluators_id.sidor_wounded_base + 1
  }

  local manager = object:motivation_action_manager()
  manager:add_evaluator(
    properties.wounded, this.evaluator_wound( "wounded", st )
  )
  manager:add_evaluator(
    properties.can_fight, this.evaluator_can_fight( "can_fight", st )
  )

  local action = this.action_wounded( "wounded_action", st )
  action:add_precondition( world_property( stalker_ids.property_alive, true ) )
  action:add_precondition( world_property( properties.wounded, true ) )
  action:add_effect( world_property( properties.wounded, false ) )
  action:add_effect( world_property( stalker_ids.property_enemy, false ) )
  action:add_effect( world_property( properties.can_fight, true ) )
  manager:add_action( operators.wounded, action )

  state_mgr.add_to_idle_preconditions( manager, { properties.wounded } )

  action = manager:action( xr_actions_id.alife )
  action:add_precondition( world_property( properties.wounded, false ) )

  action = manager:action( stalker_ids.action_gather_items )
  action:add_precondition( world_property( properties.wounded, false ) )

  action = manager:action( stalker_ids.action_combat_planner )
  action:add_precondition( world_property( properties.wounded, false ) )
  action:add_precondition( world_property( properties.can_fight, true ) )

  action = manager:action( stalker_ids.action_danger_planner )
  action:add_precondition( world_property( properties.wounded, false ) )
  action:add_precondition( world_property( properties.can_fight, true ) )

  action = manager:action( stalker_ids.action_anomaly_planner )
  action:add_precondition( world_property( properties.wounded, false ) )
  action:add_precondition( world_property( properties.can_fight, true ) )
end


-- Вызывается только в начале на чтении логики, создает экшены,
-- эвалуаторы и производит первичную настройку.
function set_wounded( npc, ini, scheme, section )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
  if not st.wound_manager then
    st.wound_manager = Cwound_manager( npc, st )
  end
end


-- Вызывается на переключении на новую секцию. Производит вычитывание
-- настроек из текущей секции.
function reset_wounded( npc, scheme, st, section )
  local wounded_section
  if ( not scheme ) or scheme == "nil" then
    wounded_section = utils.cfg_get_string(
      st.ini, st.section_logic, "wounded", npc, false, ""
    )
  else
    wounded_section = utils.cfg_get_string(
      st.ini, section, "wounded", npc, false, ""
    )
  end
  init_wounded( npc, st.ini, wounded_section, st.wounded, scheme )
  st.wounded.wound_manager:hit_callback()
end


-- Функция чтения настроек. В нее передается секция, откуда их нужно читать.
local wounded_by_state = {
  [ 0 ] = "wounded_heavy",
  [ 1 ] = "wounded_heavy_2",
  [ 2 ] = "wounded_heavy_3"
}

function init_wounded( npc, ini, section, st, scheme )
  if
    tostring( section ) == st.wounded_section and tostring( section ) ~= "nil"
  then
    return
  end

  st.wounded_section = utils.to_str( section )
  local def = {}
  local npc_community = npc:character_community()
  if is_pseudo_wounded( npc:name() ) then
    local state = wounded_by_state[ math.fmod( npc:id(), 3 ) ]
    def.hp_state     = "50|" .. state .. "@nil"
    def.hp_state_see = "50|" .. state .. "@nil"
    def.psy_state    = ""
    def.hp_victim    = "50|nil"
    def.hp_cover     = "50|false"
    def.hp_fight     = "50|false"
    def.syndata      = ""
    def.help_dialog  = nil
    def.help_start_dialog = nil
    def.use_medkit   = false

  elseif
    npc_community == "monolith"
    or like_monolith[ npc:name() ] or like_monolith[ npc:profile_name() ]
  then
    local state = wounded_by_state[ math.fmod( npc:id(), 3 ) ]
    def.hp_state     = "0|" .. state .. "@nil"
    def.hp_state_see = "0|" .. state .. "@nil"
    def.psy_state    = ""
    def.hp_victim    = "0|nil"
    def.hp_cover     = "0|false"
    def.hp_fight     = "0|false"
    def.syndata      = ""
    def.help_dialog  = nil
    def.help_start_dialog = nil
    def.use_medkit   = false

  elseif npc_community == "zombied" then
    def.hp_state     = "50|wounded_zombie@nil"
    def.hp_state_see = "50|wounded_zombie@nil"
    def.psy_state    = ""
    def.hp_victim    = "50|nil"
    def.hp_cover     = "50|false"
    def.hp_fight     = "50|false"
    def.syndata      = ""
    def.help_dialog  = nil
    def.help_start_dialog = nil
    def.use_medkit   = false

  elseif npc_community == "freedom" then
    local state = wounded_by_state[ math.fmod( npc:id(), 3 ) ]
    def.hp_state     = "10|" .. state .. "@help_heavy"
    def.hp_state_see = "10|" .. state .. "@help_heavy"
    def.psy_state    = "50|{=best_pistol}psy_armed,psy_pain@wounded_psy|20|{=best_pistol}psy_shoot,psy_pain@{=best_pistol}wounded_psy_shoot,wounded_psy"
    def.hp_victim    = "10|nil"
    def.hp_cover     = "10|false"
    def.hp_fight     = "10|false"
    def.syndata      = ""
    def.help_dialog  = "dm_help_wounded_medkit_dialog"
    def.help_start_dialog = nil
    def.use_medkit   = true

  elseif npc_community == "dolg" then
    local state = wounded_by_state[ math.fmod( npc:id(), 3 ) ]
    def.hp_state     = "10|" .. state .. "@help_heavy"
    def.hp_state_see = "10|" .. state .. "@help_heavy"
    def.psy_state    = "50|{=best_pistol}psy_armed,psy_pain@wounded_psy|20|{=best_pistol}psy_shoot,psy_pain@{=best_pistol}wounded_psy_shoot,wounded_psy"
    def.hp_victim    = "10|nil"
    def.hp_cover     = "10|false"
    def.hp_fight     = "10|false"
    def.syndata      = ""
    def.help_dialog  = "dm_help_wounded_medkit_dialog"
    def.help_start_dialog = nil
    def.use_medkit   = true

  else
    local state = wounded_by_state[ math.fmod( npc:id(), 3 ) ]
    def.hp_state     = "25|" .. state .. "@help_heavy"
    def.hp_state_see = "25|" .. state .. "@help_heavy"
    def.psy_state    = "50|{=best_pistol}psy_armed,psy_pain@wounded_psy|20|{=best_pistol}psy_shoot,psy_pain@{=best_pistol}wounded_psy_shoot,wounded_psy"
    def.hp_victim    = "10|nil"
    def.hp_cover     = "10|false"
    def.hp_fight     = "10|false"
    def.syndata      = ""
    def.help_dialog  = "dm_help_wounded_medkit_dialog"
    def.help_start_dialog = nil
    def.use_medkit   = true
  end

  if tostring( section ) == "nil" then
    -- Загружаем дефолты!
    st.hp_state     = xr_meet.parse_data( npc, def.hp_state     )
    st.hp_state_see = xr_meet.parse_data( npc, def.hp_state_see )
    st.psy_state    = xr_meet.parse_data( npc, def.psy_state    )
    st.hp_victim    = xr_meet.parse_data( npc, def.hp_victim    )
    st.hp_cover     = xr_meet.parse_data( npc, def.hp_cover     )
    st.hp_fight     = xr_meet.parse_data( npc, def.hp_fight     )
    st.syndata      = xr_meet.parse_syn_data(npc, def.syndata   )
    st.help_dialog  = def.help_dialog
    st.help_start_dialog = nil
    st.use_medkit   = def.use_medkit
  else
    st.hp_state     = xr_meet.parse_data(
      npc,
      utils.cfg_get_string(
        ini, section, "hp_state", npc, false, "", def.hp_state
      )
    )
    st.hp_state_see = xr_meet.parse_data(
      npc,
      utils.cfg_get_string(
        ini, section, "hp_state_see", npc, false, "", def.hp_state_see
      )
    )
    st.psy_state    = xr_meet.parse_data(
      npc,
      utils.cfg_get_string(
        ini, section, "psy_state", npc, false, "", def.psy_state
      )
    )
    st.hp_victim    = xr_meet.parse_data(
      npc,
      utils.cfg_get_string(
        ini, section, "hp_victim", npc, false, "", def.hp_victim
      )
    )
    st.hp_cover     = xr_meet.parse_data(
      npc,
      utils.cfg_get_string(
        ini, section, "hp_cover", npc, false, "", def.hp_cover
      )
    )
    st.hp_fight     = xr_meet.parse_data(
      npc,
      utils.cfg_get_string(
        ini, section, "hp_fight", npc, false, "", def.hp_fight
      )
    )
    st.syndata      = xr_meet.parse_syn_data(
      npc,
      utils.cfg_get_string(
        ini, section, "syndata", npc, false, "", def.syndata
      )
    )
    st.help_dialog  = utils.cfg_get_string(
      ini, section, "help_dialog", npc, false, "", def.help_dialog
    )
    st.help_start_dialog = utils.cfg_get_string(
      ini, section, "help_start_dialog", npc, false, "", nil
    )
    st.use_medkit   = utils.cfg_get_bool(
      ini, section, "use_medkit", npc, false, def.use_medkit
    )
  end

  -- флажок, что функция хотя бы раз вызывалась
  st.wounded_set = true
end


function unlock_medkit(npc)
  if db.storage[ npc:id() ].wounded then
    db.storage[ npc:id() ].wounded.wound_manager:unlock_medkit()
  end
end


function can_use_medkit( npc )
  if db.storage[ npc:id() ].wounded then
    return db.storage[ npc:id() ].wounded.wound_manager.can_use_medkit
  end
end



function is_wounded( npc )
--[=[
  if not ( npc:is_stalker() and npc:alive() ) then return false end
  if tostring( xr_logic.pstor_retrieve( npc, "wounded_state" ) ) ~= "nil" then
    return true
  else
    return false
  end
--]=]
  return ( npc:is_stalker() and npc:alive() and npc:wounded() )
end


function hit_callback( npc_id )
  if npc_id and db.storage[ npc_id ] then
    -- предпроверка усилена с целью отладки KamikaZze 03/03/2009
    if
      db.storage[ npc_id ].wounded
      and db.storage[npc_id].wounded.wound_manager
    then
      db.storage[ npc_id ].wounded.wound_manager:hit_callback()
    end
  end
end


function is_heavy_wounded_by_id( npc_id )
  if
    npc_id and db.storage[ npc_id ] and db.storage[ npc_id ].wounded
  then
    -- предпроверка усилена KamikaZze 07/04/2009
    return tostring( db.storage[ npc_id ].wounded.wound_manager.state ) ~= "nil"
  end
  return false
end


function is_psy_wounded_by_id( npc_id )
  if
    npc_id and db.storage[ npc_id ] and db.storage[ npc_id ].wounded
  then
    -- предпроверка усилена с целью отладки KamikaZze 18/05/2009
    local mgr = db.storage[npc_id].wounded.wound_manager
    return mgr.state == "psy_pain"
      or mgr.state == "psy_armed"
      or mgr.state == "psy_shoot"
      or mgr.state == "psycho_pain"
      or mgr.state == "psycho_shoot"
  end
  return false
end


-- Возвращает угол между проекциями векторов vec1 и vec2 на
-- горизонтальную плоскость положительный угол - доворот vec1 до vec2
-- по часовой.
function horz_angle( vec1, vec2 )
  local x = vec2.x * vec1.x + vec2.z * vec1.z
  local y = -vec2.z * vec1.x + vec2.x * vec1.z -- повернули систему координат
  return math.atan2( y, x )     -- угол доворота от -pi до pi
end


-- Помощь раненому
function help_wounded( npc )
  if
    like_monolith[ npc:name() ] or like_monolith[ npc:profile_name() ]
    or npc:name() == "esc_vagon_wounded" -- Толик
    or npc:name() == "gar_wounded_bandit" -- раненый бандит на Свалке
    or npc:name() == "val_escort_bandit_halfdead" -- Монгол
  then
    return
  end
  local snd = xr_sound.get_safe_sound_object(
    "characters_voice\\human_01\\newbie\\help\\wounded_thanx\\thanx_"
      .. math.random( 1, 3 )
  )
  snd:play_no_feedback( npc, sound_object.s3d, 0, npc:position(), 1.0 )
  npc:set_character_community( "stalker", 0, 0 )
  npc:set_relation( game_object.friend, db.actor )
  npc:remove_memory_object( db.actor )
  if not is_special_help_wounded( npc ) then
    if npc:character_reputation() < 0 then
      npc:change_character_reputation( 0 - npc:character_reputation() )
    end
    reset_npc_logic( npc )
    xr_gulag.resetJob( npc )
    local sobj = alife():object( npc:id() )
    if sobj then
      amkii_equip.set_community_visual( npc, true )
      sak.make_nepis_free( sobj )
      sobj:brain():can_choose_alife_tasks( true )
      sobj:brain():update()
    end
  end
end


function custom_change( id, name )
  local sobj = alife():object( id )
  if sobj and sobj:name() == name and sobj:alive() then
    sobj.custom_data = ""
    local npc = level.object_by_id( id )
    if npc then
      reset_npc_logic( npc )
      xr_gulag.resetJob( npc )
    end
    smart_terrain.unregister_npc( sobj )
    dsh.clear_smart_terrain_conditions( sobj )
    sobj:brain():can_choose_alife_tasks( true )
    sobj:brain():update()
  end
end


function reset_npc_logic( obj )
  local npc_id = obj:id()
  db.storage[ npc_id ].overrides      = nil
  xr_logic.reset_generic_schemes_on_scheme_switch( obj, "nil", "nil" )
  db.storage[ npc_id ].active_section = nil
  db.storage[ npc_id ].active_scheme  = nil
end


function get_npc_rank( obj )
  local sobj = alife():object( obj:id() )
  if sobj and sobj.rank and sobj:rank() then
    return math.floor( sobj:rank() / 290 )
  end
  return nil
end


function custom_change2( actor, npc )
  custom_change( npc:id(), npc:name() )
end
