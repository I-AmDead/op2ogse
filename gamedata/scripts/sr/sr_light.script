-- -*- mode: lua; coding: windows-1251-dos -*-

-- в этих анимациях фонарики не включать
local light_off_states = {
  [ "sleep"         ] = true,
  [ "wounded_heavy" ] = true,
}


function attach( sm )
  sm:subscribe({ signal = "on_destroy",   fun = this.on_destroy   })
  sm:subscribe({ signal = "on_npc_death", fun = this.on_death     })
  sm:subscribe({ signal = "on_npc_net_destroy", fun = this.on_npc_destroy })
  sm:subscribe({ signal = "on_npc_spawn", fun = this.on_npc_spawn })
end


function on_npc_spawn( obj, binder )
  if not obj:alive() then return end
  local s = {
    [ "signal" ] = "on_update",
    [ "fun"    ] = this.on_update,
    [ "self"   ] = obj,
  }
  binder[ "sr_light.subscribed" ] = s
  ogse_signals.get_mgr():subscribe( s )
end


function on_update( obj )
  ogse_signals.get_mgr():reschedule( math.random( 6000, 12000 ) )
  check_light( obj )
end


function on_death( obj )
  unsubscribe( obj )
  check_light( obj )
end


function on_destroy()
  clean_up()
end


function on_npc_destroy( obj )
  local binder  = unsubscribe( obj )
  local torch_t = binder[ "sr_light.torch_t" ]
  if torch_t then
    torch_t:stop()
    binder[ "sr_light.torch_t" ] = nil
  end
end


function unsubscribe( obj )
  local binder     = obj:binded_object()
  local subscribed = binder[ "sr_light.subscribed" ]
  if subscribed then
    ogse_signals.get_mgr():unsubscribe( subscribed )
  end
  binder[ "sr_light.subscribed" ] = nil
  return binder
end


local light_zones = {}

class "action_light"
function action_light:__init ( obj, storage )
  self.object = obj
  self.st     = storage
  self.active = false
  self.id     = obj:id()
end


function action_light:reset_scheme()
  light_zones[ self.id ] = self
end


function action_light:update( delta )
  local actor = db.actor
  if xr_logic.try_switch_to_another_section( self.object, self.st, actor ) then
    self.active   = false
    self.stalkers = {}
    light_zones[ self.id ] = nil
    return
  end
  self.active = true
end


function action_light:check_stalker( stalker )
  if self.active == false then
    return false, false
  end
  if stalker and self.object:inside( stalker:position() ) then
    return self.st.light, true
  end
  return false, false
end


function add_to_binder( npc, ini, scheme, section, storage )
  local new_action = action_light( npc, storage )
  xr_logic.subscribe_action_for_events( npc, storage, new_action )
end


function set_scheme( npc, ini, scheme, section, gulag_name )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
  st.logic = xr_logic.cfg_get_switch_conditions( ini, section, npc )
  st.light = utils.cfg_get_bool( ini, section, "light_on", npc, false, false )
end


function delay_torch_action( binder, func )
  binder[ "sr_light.torch_t" ] = dsh.rt_exec_on_update(
    function()
      func()
      binder[ "sr_light.torch_t" ] = nil
    end
  )
end


function check_light( stalker )
  if not stalker then return end

  local torch = stalker:item_in_slot( 9 )
  if not ( torch and torch:is_torch() ) then
    local torch = stalker:object( "device_torch" )
    if not torch then return end
  end

  local light  = false
  local forced = false

  local binder = stalker:binded_object()
  if not stalker:alive() then
    delay_torch_action(
      binder,
      function() torch:enable_attachable_item( false ) end
    )
    return
  end

  --' Проверка по лайтзонам
  if not forced then
    for k, v in pairs( light_zones ) do
      light, forced = v:check_stalker( stalker )
      if forced == true then
        break
      end
    end
  end

  local weather = dsh_cop_weather.monitoring_weather_sect
  if not forced then
    --' Проверка по времени суток (ночью всегда включено)
    local htime = level.get_time_hours()
    if htime then
      if
        ( htime <= 5 or htime >= 20 )
        or ( weather and weather == "storm" )
      then
        light = true
      else
        light = false
      end
    end

    --' Проверка на индор-аутдор (внутри всегда включено)
    if light == false then
      if isIndoor( level.name() ) then
        light = true
      end
    end
  end

  --' Проверка по активному действию
  if not forced and light == true then
    -- Фонарики должны быть выключены у костра
    local scheme = db.storage[ stalker:id() ].active_scheme
    local st_mgr = db.storage[ stalker:id() ].state_mgr
    if
      scheme == "kamp" or scheme == "camper"
      or light_off_states[ state_mgr.get_state( stalker ) ]
    then
      light  = false
      forced = true
    end
  end

  if ( not forced ) and light == true then
    -- Фонарики должны быть выключены в бою. Но если в бою идет поиск
    -- врага - то включены.
    if
      xr_wounded.is_wounded( stalker )
      -- or xrs_battle_ai.get_target( stalker ) or stalker:best_enemy()
    then
      light = false
    end
    local enemy = xrs_battle_ai.get_target( stalker ) or stalker:best_enemy()
    if
      enemy and (
        xrs_battle_ai.has_actor_in_targets( stalker )
        or ( enemy:is_stalker() and enemy:character_community() ~= "zombied" )
      )
    then
      light = false
    end
  end

  local sr_light_updated = binder.sr_light_updated
  delay_torch_action(
    binder,
    function()
      if not sr_light_updated then
        local torch = get_torch_obj( torch )
        torch:set_brightness( 0.2 + 0.8 * math.random() )
      end
      torch:enable_attachable_item( light )
    end
  )

  binder.sr_light_updated = true
end


function clean_up()
  light_zones = {}
end
