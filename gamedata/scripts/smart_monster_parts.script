-- -*- mode: lua; coding: windows-1251-dos -*-

local art_rnd      = 0.1   -- вероятность спауна артефакта
-- удалять часть, сгенерированную конфигом
local cleanup_default_parts = true
local red_part_rnd = 0.05  -- вероятность спауна красной части
local spawn_max    = false -- спаунить все неповрежденные части или только 1


function attach( sm )
  sm:subscribe({ signal = "on_first_update",  fun = this.on_first_update })
  sm:subscribe({ signal = "on_monster_death", fun = this.death_spawn })
  sm:subscribe({ signal = "on_monster_before_hit", fun = this.main_check })
end


function on_first_update()
  ogse_signals.get_mgr():subscribe({ signal = "on_take", fun = this.on_take })
end


local massive = {}
function main_check( obj, hit_data )
  if
    not ( hit_data.who and hit_data.who:is_actor() and hit_data.bone_id )
  then
    return
  end
  local mob = load_cfg( obj:section() )
  if not mob.active then return end
  if battle.is_volna_monster( obj ) then return end
  if
    hit_data.hit_type == hit.explosion
    or hit_data.hit_type == hit.burn
  then
    -- после взрыва или огнемета частей не остается
    massive[ obj:id() ] = 1000
    return
  end
  local bname = obj:get_bone_name( hit_data.bone_id )
  ASSERT(
    bname, "[%s]: no bone name for id %s", script_name(), hit_data.bone_id
  )
  for _, re in ipairs( mob.bones ) do
    if string.find( bname, re ) then
      massive[ obj:id() ] = ( massive[ obj:id() ] or 0 ) + 1
      break
    end
  end
end


function spawn_parts( obj, number, who )
  if not number then number = 0 end
  if who:is_actor() then
    spawn_parts_for_actor( obj, number )
  elseif
    ( IsStalker( who ) or IsMonster( who ) )
    and not watcher_act.is_quest_npc( who )
  then
    transfer_everything( obj, who )
  end
end


function spawn_parts_for_actor( obj, number )
  local mob = load_cfg( obj:section() )
  if not mob.active then return end
  local spawned = false
  if number < mob.max_hit then
    local num_of_parts = 1
    if spawn_max or mob.spawn_max then
      num_of_parts = mob.max_hit - number
    end
    if obj:object( mob.spawn_part ) then
      num_of_parts = num_of_parts - 1
    elseif
      mob.dont_spawn_if_object
      and obj:object( mob.dont_spawn_if_object )
    then
      num_of_parts = num_of_parts - 1
    end
    if num_of_parts > 0 then
      for i = 1, num_of_parts do
        spawn_part_in_inv( obj, mob.spawn_part, mob.spawn_red_part )
        spawned = true
      end
    end
  elseif cleanup_default_parts then
    obj:iterate_inventory(
      function( obj, item )
        if item:section() == mob.spawn_part then
          local sobj = alife():object( item:id() )
          if sobj then
            alife():release( sobj )
          end
        end
      end,
      obj
    )
  end
  if mob.likes_arts and not is_handmade_monster( obj ) then
    local rnd = dsh.get_next_random(
      "smart_monster_parts.spawn_parts_for_actor.likes_art.rnd"
    )
    if rnd < art_rnd then
      local art = amk_anoms.get_random_art_sect()
      if art then
        local prop = amk_utils.get_item_props( art )
        if prop.has_af_dyn then
          art  = amk_anoms.make_dyn_art_sect( art )
          prop = amk_utils.get_item_props( art )
        end
        if prop.af_bio_sect then art = prop.af_bio_sect end
        local sect = get_string( art, "smart_monster_parts.create_item" )
        ASSERT( sect, "create_item not found for %s", art )
        spawn_part_in_inv( obj, sect )
        spawned = true
      end
    end
  end
  if spawned then
    local binder = obj:binded_object()
    binder[ "smart_monster_parts.spawned" ] = true
  end
end


function spawned( obj, binder )
  if not binder then binder = obj:binded_object() end
  if binder[ "smart_monster_parts.spawned" ] then
    return true
  end
  return false
end


function on_take( obj )
  local sect = get_string( obj:section(), "smart_monster_parts.inv_item" )
  if sect then
    local sobj = alife():object( obj:id() )
    if sobj then
      alife():release( sobj )
    end
    local prop = amk_utils.get_item_props( sect )
    sobj = ogse.spawn_item_in_inv( prop.af_bio_sect or sect )
    if dsh.is_artefact( sobj:section_name() ) then
      local tgt = level.get_car_body_target()
      if tgt then
        local mob = load_cfg( tgt:section() )
        if mob.active and mob.likes_arts then
          actor_stats.add_points( "exp", "exp_burer_artefacts", 1, 1 )
        end
      end
    end
    return true
  end
end


function spawn_part_in_inv( obj, part, red_part )
  if red_part then
    local rnd = dsh.get_next_random( "smart_monster_parts.red_part.rnd" )
    if rnd < red_part_rnd then
      part = red_part
    end
  end
  amk.spawn_item_in_inv( part, obj )
end


function death_spawn( obj, who )
  if alife():object( obj:id() ) and not battle.is_volna_monster( obj ) then
    spawn_parts( obj, massive[ obj:id() ], who )
  end
  massive[ obj:id() ] = nil
end


function transfer_everything( from_obj, to_obj )
  local items = {}
  from_obj:iterate_inventory(
    function( obj, item )
      if
        alife():object( item:id() )
        and not watcher_act.do_not_touch( item )
      then
        table.insert( items, item )
      end
    end,
    from_obj
  )
  for _, item in ipairs( items ) do
    from_obj:transfer_item( item, to_obj )
  end
end


function is_handmade_monster( obj )
  local is_handmade = false
  local sobj = alife():object( obj:id() )
  if sobj then
    local ini = sobj:spawn_ini()
    if ini:section_exist( "dsh" ) then
      is_handmade = get_bool( "dsh", "handmade", false, ini )
    end
  end
  return is_handmade
end


function fake_bind( obj )
end


local loaded_cfg = {}
function load_cfg( sect )
  if not loaded_cfg[ sect ] then
    local t = {}
    loaded_cfg[ sect ] = t
    t.active = get_bool( sect, "smart_monster_parts.active", false )
    if t.active then
      t.bones      = parse_names(
        get_string( sect, "smart_monster_parts.bones" )
      )
      t.dont_spawn_if_object = get_string(
        sect, "smart_monster_parts.dont_spawn_if_object"
      )
      t.likes_arts = get_bool( sect, "smart_monster_parts.likes_arts", false )
      t.max_hit    = get_u32( sect, "smart_monster_parts.max_hit" )
      t.spawn_max  = get_bool( sect, "smart_monster_parts.spawn_max", false )
      t.spawn_part = get_string( sect, "smart_monster_parts.spawn_part" )
      t.spawn_red_part = get_string(
        sect, "smart_monster_parts.spawn_red_part"
      )
    end
  end
  return loaded_cfg[ sect ]
end
